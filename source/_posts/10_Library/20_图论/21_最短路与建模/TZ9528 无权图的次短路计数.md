---
title: '[Leaf] [TZ9528] 无权图的次短路计数'
tags:
  - 图论/最短路
  - null
difficulty: P2
categories:
  - 10_Library
  - 20_图论
  - 21_最短路与建模
abbrlink: d72fddf4
date: 2026-01-05
---
  

# [9528:无权图的次短路计数](https://www.tzcoder.cn/acmhome/problemdetail.do?method=showdetail&id=9528)

## 1. 核心逻辑

- **模型抽象**: 在给定无权图中，寻找路径长度严格大于最短路且最小的路径（次短路）的数量。
    
- **状态空间扩展**: 将每一个物理节点 $u$ 投影为两个逻辑状态：
    
    1. $(u, 0)$: 到达 $u$ 的最短路径状态。
        
    2. $(u, 1)$: 到达 $u$ 的严格次短路径状态。
        
- **破局路径**: 使用 Dijkstra 维护双维度表 `dist[N][2]` 和 `cnt[N][2]`。在松弛边 $(u, v)$ 时，根据新路径长度 $L$ 与 $dist[v][0], dist[v][1]$ 的关系执行四段式转移逻辑：
    
    - **新最短**: $L < dist[v][0]$。原最短降级为次短，新最短上线。
        
    - **等最短**: $L == dist[v][0]$。仅累加最短路径计数。
        
    - **新次短**: $dist[v][0] < L < dist[v][1]$。更新次短路径。
        
    - **等次短**: $L == dist[v][1]$。仅累加次短路径计数。
        
- **物理直觉**: Dijkstra 的堆结构保证了状态是从小到大确定的。虽然在无权图中 BFS 效率更高，但 Dijkstra 在逻辑层面上更具“审计感”，能处理所有正权边场景。
    

## 2. 代码实现

{% fold info @AcCode #trd%}

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int maxn = 2e3 + 50;
const int inf = 1e9;

struct State {
	int u, d, type;
	bool operator < ( const State &oth ) const {
		return d > oth.d;
	}
};

int n, m;
vector< int > adj[maxn];
int dist[maxn][2];
int cnt[maxn][2];

void dijkstra( )
{
	for( int i = 1; i <= n; ++ i )
	{
		dist[i][0] = dist[i][1] = inf;
		cnt[i][0] = cnt[i][1] = 0;
	}

	priority_queue< State > pq;

	pq.push({ 1, 0, 0 });

	dist[1][0] = 0;
	cnt[1][0] = 1;
	
	while( !pq.empty( ) )
	{
		auto [u, d, type] = pq.top( );
		pq.pop( );

		if( d > dist[u][type] ) continue;
		
		for( int v : adj[u] )
		{
			int nd = d + 1;

			if( nd < dist[v][0] )
			{
				dist[v][1] = dist[v][0];
				cnt[v][1] = cnt[v][0];
				pq.push( {v, dist[v][1], 1} );

				dist[v][0] = nd;
				cnt[v][0] = cnt[u][type];
				pq.push( {v, dist[v][0], 0} );
			}
			else if( nd == dist[v][0] )
			{
				cnt[v][0] += cnt[u][type];
			}
			else if( nd < dist[v][1] )
			{
				dist[v][1] = nd;
				cnt[v][1] = cnt[u][type];
				pq.push( {v, dist[v][1], 1} );
			}
			else if( nd == dist[v][1] )
			{
				cnt[v][1] += cnt[u][type];
			}

		}
	}
}

int main( )
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	cin >> n >> m;
	for( int i = 1; i <= m; ++ i )
	{
		int u, v;
		cin >> u >> v;
		adj[u].push_back( v );
		adj[v].push_back( u );
	}
	
	dijkstra( );
	
	if( dist[n][1] == inf ) cout << -1 << '\n';
	else cout << cnt[n][1] << '\n';
	
	return 0;
}
```

{% endfold %}

## 3. 复盘

- **复杂度**: $O(K \cdot M \log N)$，此处 $K=2$。
    
- **降维映射**: 在 Dijkstra 的视角下，次短路只是“状态向量”的一个分量。
		
	- 通过在堆中维护 `type` 标签，我们将原本需要复杂拓扑分析的问题降维为简单的状态转移。
    
- **关联母题**: [[Note] 次短路计数与状态空间扩展]