---
title: '[Leaf] [P1886] 滑动窗口 / [模板] 单调队列'
tags:
  - 单调性/单调队列
  - 算法/RMQ
  - 难度/P1/基础
categories:
  - 10_Library
  - 00_基础算法
  - 01_降维技巧
abbrlink: 7d6e628
date: 2025-11-07
---
# [Luogu-P1886](https://www.luogu.com.cn/problem/P1886) 滑动窗口

## 1. 核心逻辑

- **问题本质**: $O(N)$ 维护滑动窗口的最值（最大与最小）。
    
- **破局转换**: 淘汰“不再如此时新，也不如此时强”的过时元素。
    
## 2. 代码实现

{% fold info @AcCode %}

```cpp
// P1886 滑动窗口
// Key Logic: Standard Monotonic Queue Template (Max & Min)

#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e6 + 50;
int n, k;
int a[ maxn ];

void solve( bool get_max )
{
    deque< int > q;
    for( int i = 1; i <= n; ++ i )
    {
        while( !q.empty( ) && ( get_max ? a[ q.back( ) ] <= a[ i ] : a[ q.back( ) ] >= a[ i ] ) )
        {
            q.pop_back( );
        }
        q.push_back( i );
        
        if( q.front( ) <= i - k ) q.pop_front( );
        
        if( i >= k )
        {
            cout << a[ q.front( ) ] << ( i == n ? "" : " " );
        }
    }
    cout << "\n";
}

int main( )
{
    ios::sync_with_stdio( 0 );
    cin.tie( 0 );

    cin >> n >> k;
    for( int i = 1; i <= n; ++ i ) cin >> a[ i ];

    solve( false ); // Min
    solve( true );  // Max

    return 0;
}
```

{% endfold %}

## 3. 归档备注

- 单调队列的母题，必须熟练掌握。
    
- 重点理解下标入队与 `a[q.front()]` 取值的逻辑。

- **关联知识点**：[[单调栈与队列]] 