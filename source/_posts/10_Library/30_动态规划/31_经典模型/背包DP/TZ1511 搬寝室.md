---
title: '[Leaf] [TZ1511] 搬寝室'
tags:
  - DP/背包
  - 难度/P2/提高
categories:
  - 10_Library
  - 30_动态规划
  - 31_经典模型
abbrlink: f743e645
date: 2026-01-05
---
    
# [1511:搬寝室](https://www.tzcoder.cn/acmhome/problemdetail.do?method=showdetail&id=1511)

## 1. 核心逻辑

- **模型抽象**: 从 $n$ 个数中选取 $2k$ 个数，组成 $k$ 对，使每对差值的平方和最小。
    
- **破局路径**:
    
    1. **排序不变量**: 根据排序不等式，要使平方差之和最小，每一对配对的元素在升序序列中必然是相邻的。排序是消除后效性的物理前提。
        
    2. **状态定义**: $dp[i][j]$ 表示在前 $i$ 件物品中选出 $j$ 对的最小疲劳度。
        
    3. **状态转移**:
        
        - 不选第 $i$ 件物品：$dp[i][j] = dp[i-1][j]$
            
        - 选取 $(i, i-1)$ 作为第 $j$ 对：$dp[i][j] = dp[i-2][j-1] + (a[i] - a[i-1])^2$
            
        - 取二者最小值：$dp[i][j] = \min(dp[i-1][j], \ dp[i-2][j-1] + cost)$
            
- **细节处理**:
    
    - **初始化**: `dp[0][0] = 0` 是逻辑奇点，必须确保 `dp[i][0] = 0` 且其余状态为 $\infty$。
        
    - **数值边界**: 单次疲劳度最大 $2^{30}$，总和需用 `long long` 承载，`inf` 设为 `1e18`。
        

## 2. 代码实现

{% fold info @AcCode %}

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int maxn = 2000 + 50;
const ll inf = 1e18;

ll dp[maxn][maxn];
ll a[maxn];
int n, k;

ll dist( int x, int y )
{
	return ( a[x] - a[y] ) * ( a[x] - a[y] );
}

int main( )
{
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	
	while( cin >> n >> k )
	{
		for( int i = 1; i <= n; ++ i )
		{
			cin >> a[i];
		}
		
		sort( a + 1, a + n + 1 );
		
		memset( dp, 0x3f, sizeof( dp ) );
		
		for( int i = 0; i <= n; ++ i )
		{
			dp[i][0] = 0;
		}
		
		for( int i = 2; i <= n; ++ i )
		{
			for( int j = 1; j * 2 <= i; ++ j )
			{
				int cost = dist( i, i-1 );
				dp[i][j] = min( dp[i-1][j], dp[i-2][j-1] + cost );
			}
		}
		
		cout << dp[n][k] << '\n';
	}
	
	return 0;
}

```

{% endfold %}

## 3. 复盘

- **复杂度**: $O(n \cdot k)$。
    
- **灵感反思**: 本题的难点不在于转移方程，而在于对“相邻配对”这一物理性质的洞察。如果没有排序，问题将降维打击为复杂的匹配问题。
    
- **关联母题**: [[0-1 背包]] —— 本质是带约束的线性决策。