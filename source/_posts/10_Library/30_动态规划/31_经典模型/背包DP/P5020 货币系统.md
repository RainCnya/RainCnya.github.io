---
title: '[Leaf] [P5020] 货币系统'
tags:
  - DP/背包
  - 数论
  - 难度/P2/提高
categories:
  - 10_Library
  - 30_动态规划
  - 31_经典模型
abbrlink: 910566d1
date: 2025-11-17 00:00:00
---
# [Luogu-P5020](https://www.luogu.com.cn/problem/P5020) 货币系统

## 1. 核心逻辑

- **问题本质**: 求给定面值集合 $A$ 的极大无关子集（即最小的能凑出相同金额集的子集）。
    
- **破局转换**:
    
    1. **单调性**: 一个面值能否被其他面值凑出，只与其较小的面值有关。
        
    2. **背包判定**: 排序后，对每个面值 $a[i]$，检查其是否能被 $\{a[1], \dots, a[i-1]\}$ 凑出。
        
    3. **模型坍缩**: 这是一个面值上限固定的**完全背包**可达性问题。
        

## 2. 代码实现

{% fold info @AcCode %}

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxv = 25005;
int a[ 105 ], f[ maxv ], n;

void solve( ) 
{
    cin >> n;
    for( int i = 1; i <= n; ++ i ) cin >> a[ i ];
    sort( a + 1, a + n + 1 );

    memset( f, 0, sizeof( f ) );
    f[ 0 ] = 1;
    int ans = n;

    for( int i = 1; i <= n; ++ i ) 
    {
        if( f[ a[ i ] ] ) 
        {
            -- ans; // 当前面值已被更小面值凑出，冗余
            continue;
        }
        // 完全背包更新状态
        for( int j = a[ i ]; j <= a[ n ]; ++ j ) 
        {
            f[ j ] |= f[ j - a[ i ] ];
        }
    }
    cout << ans << "\n";
}

int main( ) 
{
    ios::sync_with_stdio( 0 );
    cin.tie( 0 );
    int t; cin >> t;
    while( t -- ) solve( );
    return 0;
}
```

{% endfold %}

## 3. 归档备注

- **复杂度**: $O(T \cdot n \cdot \max(A))$。
    
- **关键点**: 必须从小到大处理以维持背包的因果链条。