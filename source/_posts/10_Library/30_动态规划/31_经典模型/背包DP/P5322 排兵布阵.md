---
title: '[Leaf] [P5322] 排兵布阵'
tags:
  - DP/背包
  - 算法/排序
  - 难度/P2/省选-
categories:
  - 10_Library
  - 30_动态规划
  - 31_经典模型
abbrlink: a52e227e
date: 2025-11-22 00:00:00
---
# [Luogu-P5322](https://www.luogu.com.cn/problem/P5322) 排兵布阵

## 1. 核心逻辑

- **问题本质**: 在 $N$ 个独立的关卡中分配有限兵力 $M$，以在不同玩家之间获取最大积分。
    
- **破局转换**:
    
    1. **代价转化**: 对于关卡 $i$，若想击败 $k$ 个对手，最省兵力的方案是投入“该关卡第 $k$ 弱对手兵力的 2 倍 + 1”。
        
    2. **策略枚举**: 每个关卡都是一个**物品组**。在每个组内，我们可以选择击败 $0, 1, \dots, S$ 个对手，获得相应的积分 $0, i, \dots, i \cdot S$。
        
    3. **模型归一**: 标准分组背包。
        

## 2. 代码实现

{% fold info @AcCode %}

```cpp
#include <bits/stdc++.h>
using namespace std;

int s, n, m, a[ 105 ][ 105 ], f[ 20005 ];

int main( ) 
{
    cin >> s >> n >> m;
    for( int i = 1; i <= s; ++ i ) 
    {
        for( int j = 1; j <= n; ++ j ) cin >> a[ j ][ i ];
    }

    for( int i = 1; i <= n; ++ i ) sort( a[ i ] + 1, a[ i ] + s + 1 );

    for( int i = 1; i <= n; ++ i ) 
    {
        for( int j = m; j >= 0; -- j ) 
        {
            for( int k = 1; k <= s; ++ k ) 
            {
                int cost = 2 * a[ i ][ k ] + 1;
                if( j >= cost ) f[ j ] = max( f[ j ], f[ j - cost ] + i * k );
            }
        }
    }
    cout << f[ m ] << "\n";
    return 0;
}
```

{% endfold %}

## 3. 归档备注

- **复杂度**: $O(n \cdot m \cdot s)$。
    
- **关键点**: 预处理排序确定击败 $k$ 人的最小代价。