---
title: '[Leaf] [P1064] 金明的预算方案'
tags:
  - DP/背包
  - 难度/P2/提高
categories:
  - 10_Library
  - 30_动态规划
  - 31_经典模型
abbrlink: 8025fa2d
date: 2025-11-17 00:00:00
---
# [Luogu-P1064](https://www.luogu.com.cn/problem/P1064) 金明的预算方案

## 1. 核心逻辑

- **问题本质**: 存在主从依赖关系的 0/1 背包（选附件必选主件）。
    
- **破局转换**:
    
    1. **决策坍缩**: 由于每个主件最多只有 2 个附件，对于一个主件组，其合法策略只有 4 种：
        
        - (主件)
            
        - (主件 + 附件1)
            
        - (主件 + 附件2)
            
        - (主件 + 附件1 + 附件2)
            
    2. **模型归一**: 这 4 种策略在同一组内是**互斥**的，问题坍缩为标准的**分组背包**。
        

## 2. 代码实现

{% fold info @AcCode %}

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxw = 32005;
int n, m, f[ maxw ];
int mw[ 65 ], mv[ 65 ], fw[ 65 ][ 3 ], fv[ 65 ][ 3 ], cnt[ 65 ];

int main( ) 
{
    cin >> n >> m;
    for( int i = 1; i <= m; ++ i ) 
    {
        int w, v, q;
        cin >> w >> v >> q;
        if( !q ) mw[ i ] = w, mv[ i ] = w * v;
        else 
        {
            ++ cnt[ q ];
            fw[ q ][ cnt[ q ] ] = w;
            fv[ q ][ cnt[ q ] ] = w * v;
        }
    }

    for( int i = 1; i <= m; ++ i ) 
    {
        if( !mw[ i ] ) continue; // 跳过非主件
        for( int j = n; j >= mw[ i ]; -- j ) 
        {
            // 策略 1: 仅主件
            f[ j ] = max( f[ j ], f[ j - mw[ i ] ] + mv[ i ] );
            
            // 策略 2: 主 + 附 1
            if( j >= mw[ i ] + fw[ i ][ 1 ] ) 
                f[ j ] = max( f[ j ], f[ j - mw[ i ] - fw[ i ][ 1 ] ] + mv[ i ] + fv[ i ][ 1 ] );
            
            // 策略 3: 主 + 附 2
            if( j >= mw[ i ] + fw[ i ][ 2 ] ) 
                f[ j ] = max( f[ j ], f[ j - mw[ i ] - fw[ i ][ 2 ] ] + mv[ i ] + fv[ i ][ 2 ] );
            
            // 策略 4: 主 + 附 1 + 附 2
            if( j >= mw[ i ] + fw[ i ][ 1 ] + fw[ i ][ 2 ] ) 
                f[ j ] = max( f[ j ], f[ j - mw[ i ] - fw[ i ][ 1 ] - fw[ i ][ 2 ] ] + mv[ i ] + fv[ i ][ 1 ] + fv[ i ][ 2 ] );
        }
    }
    cout << f[ n ] << "\n";
    return 0;
}
```

{% endfold %}

## 3. 归档备注

- **复杂度**: $O(n \cdot m)$。
    
- **关键点**: 分组背包的体积循环必须在策略枚举之外（倒序），以保证物品组的 0/1 属性。