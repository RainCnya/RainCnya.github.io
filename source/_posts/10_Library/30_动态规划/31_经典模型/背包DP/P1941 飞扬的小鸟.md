---
title: '[Leaf] [P1941] 飞扬的小鸟'
tags:
  - DP/背包
  - DP/线性
  - 难度/P2/提高
categories:
  - 10_Library
  - 30_动态规划
  - 31_经典模型
abbrlink: eed28785
date: 2025-11-23 00:00:00
---
# [Luogu-P1941](https://www.luogu.com.cn/problem/P1941) 飞扬的小鸟

## 1. 核心逻辑

- **问题本质**: 在网格中规划路径，上升可以执行无限次（完全背包），下降固定每秒发生一次（0/1 背包）。
    
- **破局转换**:
    
    1. **阶段划分**: 时间时刻 $i$ 作为 DP 阶段。
        
    2. **混合转移**:
        
        - **上升**: 同一秒点多次 $\implies$ `f[i][j] = min(f[i-1][j-x], f[i][j-x]) + 1`。
            
        - **下降**: 每秒被动触发 $\implies$ `f[i][j] = min(f[i][j], f[i-1][j+y])`。
            
    3. **天花板逻辑**: 坐标超过 $M$ 统一截断为 $M$。需在上升转移后单独处理 $[M-x, M]$ 范围的贡献。
        

## 2. 代码实现

{% fold info @AcCode %}

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 10005, maxm = 2005, inf = 0x3f3f3f3f;
int n, m, p, x[ maxn ], y[ maxn ], low[ maxn ], high[ maxn ], f[ maxn ][ maxm ];
bool has_p[ maxn ];

int main( ) 
{
    cin >> n >> m >> p;
    for( int i = 0; i < n; ++ i ) cin >> x[ i ] >> y[ i ];
    for( int i = 1; i <= n; ++ i ) low[ i ] = 0, high[ i ] = m + 1;
    for( int i = 1; i <= p; ++ i ) 
    {
        int a, b, c; cin >> a >> b >> c;
        has_p[ a ] = 1; low[ a ] = b; high[ a ] = c;
    }

    memset( f, 0x3f, sizeof( f ) );
    for( int j = 1; j <= m; ++ j ) f[ 0 ][ j ] = 0;

    for( int i = 1; i <= n; ++ i ) 
    {
        // 1. 完全背包: 上升
        for( int j = x[ i - 1 ] + 1; j <= m; ++ j ) 
        {
            f[ i ][ j ] = min( f[ i - 1 ][ j - x[ i - 1 ] ], f[ i ][ j - x[ i - 1 ] ] ) + 1;
        }
        // 天花板溢出处理
        for( int j = m - x[ i - 1 ] + 1; j <= m; ++ j ) 
        {
            f[ i ][ m ] = min( { f[ i ][ m ], f[ i - 1 ][ j ], f[ i ][ j ] } ) + 1;
        }
        // 2. 0/1 背包: 下降
        for( int j = 1; j <= m - y[ i - 1 ]; ++ j ) 
        {
            f[ i ][ j ] = min( f[ i ][ j ], f[ i - 1 ][ j + y[ i - 1 ] ] );
        }
        // 3. 管道/约束清理
        for( int j = 1; j <= low[ i ]; ++ j ) f[ i ][ j ] = inf;
        for( int j = high[ i ]; j <= m; ++ j ) f[ i ][ j ] = inf;

        // 判定可达性
        bool ok = 0;
        for( int j = 1; j <= m; ++ j ) if( f[ i ][ j ] < inf ) ok = 1;
        if( !ok ) 
        {
            int cnt = 0;
            for( int k = 1; k < i; ++ k ) if( has_p[ k ] ) ++ cnt;
            cout << 0 << "\n" << cnt << "\n";
            return 0;
        }
    }

    int ans = inf;
    for( int j = 1; j <= m; ++ j ) ans = min( ans, f[ n ][ j ] );
    cout << 1 << "\n" << ans << "\n";
    return 0;
}
```

{% endfold %}

## 3. 归档备注

- **复杂度**: $O(n \cdot m)$。
    
- **关键点**: 天花板处理需覆盖从 `i-1` 层和当前 `i` 层转移而来的最大值。注意转移顺序：上升在前，下降在后。