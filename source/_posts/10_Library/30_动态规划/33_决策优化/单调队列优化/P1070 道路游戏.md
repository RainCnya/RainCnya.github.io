---
title: '[Leaf] [P1070] 道路游戏'
tags:
  - DP/线性
  - DP/优化
  - 单调性/单调队列
  - 难度/P2/省选-
categories:
  - 10_Library
  - 30_动态规划
  - 31_经典模型
abbrlink: da930cd8
date: 2025-11-23 00:00:00
---
# [Luogu-P1070](https://www.luogu.com.cn/problem/P1070) 道路游戏

## 1. 题面梗概

**中译中**: 给定一个有 $N$ 个点的环形工厂，以及 $M$ 秒时间。你在每个点可以买一个机器人，它会顺时针走 $1 \sim P$ 步，每步捡一个金币，走完就自毁。捡金币有收益，买机器人有成本。求最大净收益。

## 2. 逻辑推导

这题的难点在于，它有两个复杂的状态：”时间“ 和 ”地点“。但如果把时间和地点按两条坐标轴展开，你就会发现，机器人其实是在坐标系中斜向移动的。

### 2.1 建模

假设机器人是在时间 $j - k$ 在点 $i - k$ 购买，在时间 $j$ 到达点 $i$。

分析路径：$(i-k,j-k) \to (i-k+1,j-k+1) \to \ddots \to (i,j)$。

所以我们可以按照对角线进行分组，也就是按照 $(i - j) \pmod N$ 分组。

### 2.2 DP

**状态定义**： $f[j]$ 为时间 $j$ 的最大收益。

**状态转移**：$f[j] \max(f[j-k] + val - cost)$。 $val$ 为这一段斜向金币和， $cost$ 为购买成本。

如何快速查询斜向金币和呢？我们可以使用前缀和预处理：令$S[i][j]$ 为该点金币和。

$$
f[j] = s[i][j] + \max_{1 \leq k \leq P}(f[j-k] - s[id][j-k] - cost[id] )
$$
老问题，直接暴力转移的话，复杂度会爆炸 $O(M^2N)$。

注意到括号里那一坨只跟 对角线 $id$ 和 起始时间 $j - k$ 有关。

所以我们只需要给每一条对角线 $id$ 开一个单调队列，维护这个滑动窗口最值，即可把复杂度降维到 $O(MN)$。

## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e3 + 50;
const long long inf = 1e18;

int n, m, p;
int v[maxn][maxn];
int w[maxn];
long long dp[maxn];
long long sum[maxn][maxn];

deque< pair<long long, int> > q[maxn];

int getpre( int u )
{
    return u == 1 ? n : u - 1;
}

int main( )
{	
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);

    cin >> n >> m >> p;
    for( int i = 1; i <= n; ++ i )
        for( int j = 1; j <= m; ++ j )
            cin >> v[i][j];

    for( int i = 1; i <= n; ++ i )
        cin >> w[i];

    memset( sum, 0, sizeof( sum ) );

    for( int j = 1; j <= m; ++ j )
    {
        for( int i = 1; i <= n; ++ i )
        {
            int prev = getpre( i );
            sum[i][j] = sum[prev][j-1] + v[prev][j];
        }
    }

    for( int j = 1; j <= m; ++ j )
        dp[j] = -inf;
    dp[0] = 0;

    for( int j = 1; j <= m; ++ j )
    {
        for( int i = 1; i <= n; ++ i )
        {
            int id = ( (i - j) % n + n ) % n;
            int pid = getpre( i );

            if( dp[j - 1] > -inf )
            {
                long long val = dp[j - 1] - sum[pid][j - 1] - w[pid];
                while( !q[id].empty( ) && q[id].back( ).first <= val )
                    q[id].pop_back( );
                q[id].push_back({ val, j - 1 });
            }

            while( !q[id].empty( ) && q[id].front( ).second < j - p )
                q[id].pop_front( );
            
            if( !q[id].empty( ) )
            {
                long long res = q[id].front( ).first + sum[i][j];
                dp[j] = max( dp[j], res );
            }
        }
    }

    cout << dp[m] << '\n';
    return 0;
}

```

{% endfold %}

## 4. 复盘

- **复杂度**: $O( NM )$。
    
- **碎碎念**: 分析题意找到对角线这个不变量，这题就写出来一半了。而一旦把斜向 DP 变成线性 DP ，再用单调队列优化就是顺理成章的事。
    
- **关联笔记**: [[网格DP]] | [[单调栈与队列]]