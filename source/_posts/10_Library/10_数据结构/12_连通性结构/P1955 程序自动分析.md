---
title: '[Leaf] [P1955] 程序自动分析'
tags:
  - 数据结构/并查集
  - 策略/离散化
  - 难度/P1/提高-
categories:
  - 10_Library
  - 10_数据结构
  - 12_动态连通性
abbrlink: fad17f38
date: 2025-11-3
---
# [Luogu-P1955](https://www.luogu.com.cn/problem/P1955) 程序自动分析

## 1. 题意梗概：

**中译中**：给出一堆变量之间的关系，“相等” 和 “不相等”。判断逻辑是否完备。

## 2. 核心逻辑

**第一反应**："相等" 这个条件具备明显的传递性质。而维护这样一个**集合**，就是并查集的强项了。

接着看数据范围，我们发现约束总数 $n \leq 1e5$，而值域 $i,j \leq 1e9$。这意味着如果直接开并查集，空间会爆掉！

但是，很多变量其实根本就没出现过。因此，我们采取**离散化**策略，将所有出现过的变量收集起来，用于判断。

最后我们还需要考虑处理顺序，因为"不等"的关系要建立在”相等“关系已经完全确定后才能检验，所以我们先处理相等关系。

## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e5 + 50;

struct Node {
    int x, y, e;
} a[maxn];

int fa[maxn << 1];
int nums[maxn << 1];
int n, cnt;

bool cmp( Node x, Node y ) 
{
    return x.e > y.e;
} 

int find( int x ) 
{
    if( fa[x] == x ) return fa[x];
    else return fa[x] = find( fa[x] );
}

void solve( )
{
    cnt = 0;
    cin >> n;
    for( int i = 1; i <= n; ++ i )
    {
        cin >> a[i].x >> a[i].y >> a[i].e;
        nums[++ cnt] = a[i].x;
        nums[++ cnt] = a[i].y;
    }

    sort( nums + 1, nums + cnt + 1 );
    int m = unique( nums + 1, nums + cnt + 1 ) - (nums + 1);

    for( int i = 1; i <= n; ++ i )
    {
        a[i].x = lower_bound( nums + 1, nums + m + 1, a[i].x ) - (nums + 1);
        a[i].y = lower_bound( nums + 1, nums + m + 1, a[i].y ) - (nums + 1);
    }

    for( int i = 0; i < m; ++ i )
    {
        fa[i] = i;
    }

    sort( a + 1, a + n + 1, cmp );

    bool ok = 1;
    for( int i = 1; i <= n; ++ i )
    {
        auto& [x, y, e] = a[i];
        int rx = find( x ), ry = find( y );

        if( e == 1 ) 
        {
            fa[rx] = ry;
        }
        else if( rx == ry ) 
        {
            ok = 0;
            break;
        }
    }

    if( ok ) cout << "YES" << '\n';
    else cout << "NO" << '\n';
}

int main( ) 
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int _t;  
    cin >> _t;
    while( _t -- )
    {
        solve( );
    }
    return 0;
}
```

{% endfold %}

## 4. 复盘

- **复杂度**: $O( T \cdot (N \log N) )$。离散化排序是瓶颈。
    
- **碎碎念**:
    
    - **离散化的必要性**：如果没有离散化，你只能开 `std::map` 来存并查集，那常数大得能让你怀疑人生。
	
- **关联知识点**: [[并查集]] | [[离散化]]
