---
title: '[Leaf] [P3369] [模板] 普通平衡树 (权值线段树)'
tags:
  - 数据结构/线段树
  - 数据结构/平衡树
  - 策略/离散化
  - 难度/P2/提高
categories:
  - 10_Library
  - 10_数据结构
  - 11_树形结构
abbrlink: c74b32e1
date: 2026-01-28 16:04:24
---
# [P3369 【模板】普通平衡树 - 洛谷](https://www.luogu.com.cn/problem/P3369)

## 1. 题面梗概

**中译中**: 维护一个集合，要能加数、减数、查排名、查数值、查前驱后继。
    
## 2. 逻辑推导

这是一道平衡树的模板题，一般考虑 Splay 或者 Treap 来写。但这道题我们可以采用权值线段树来解决。

### 2.1 建模

- 我们建立一棵线段树，其下标 $[1, M]$ 对应离散化后的每一个唯一数值。
    
- **节点信息**: `cnt` 记录该权值区间内目前存在多少个数。
    
- **操作映射**:
    
    1. **插入/删除**: 在离散化后的 $ID$ 位置执行单点修改，`cnt += 1 / -1`。
        
    2. **查排名**: 查询区间 $[1, ID-1]$ 的 `cnt` 总和，结果加 $1$。
        
    3. **查第** $k$ **小**: 在线段树上进行二分。如果左子树的 `cnt` 足够，就往左走；否则减去左子树的 `cnt` 往右走。
        
    4. **查前驱**: 先查出有多少个数严格比 $x$ 小（设为 $c$），然后在线段树上找第 $c$ 小的数。
        
    5. **查后继**: 先查出有多少个数小于等于 $x$（设为 $c$），然后在线段树上找第 $c+1$ 小的数。

## 3. 代码实现

{% fold info @AcCode %}
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int maxn = 2e5 + 5;

struct Info {
    ll cnt = 0;
    static Info merge( const Info& l, const Info& r ) {
        return { l.cnt + r.cnt };
    }
};

struct Node {
    int l, r;
    Info info;
} tr[maxn << 2];

#define ls (u << 1)
#define rs (u << 1 | 1)

void push_up( int u ) { 
    tr[u].info = Info::merge( tr[ls].info, tr[rs].info ); 
}

void build( int u, int l, int r ) 
{
    tr[u].l = l, tr[u].r = r;
    tr[u].info = { 0 };
    if( l == r ) return;
    int mid = ( l + r ) >> 1;
    build( ls, l, mid );
    build( rs, mid + 1, r );
    push_up( u );
}

void modify( int u, int pos, int val ) 
{
    if( tr[u].l == tr[u].r )
    {
        tr[u].info.cnt += val;
        return;
    }
    int mid = ( tr[u].l + tr[u].r ) >> 1;
    if( pos <= mid ) modify( ls, pos, val );
    else modify( rs, pos, val );
    push_up( u );
}

Info query( int u, int l, int r ) 
{
    if( l > r ) return { 0 };
    if( l <= tr[u].l && tr[u].r <= r ) return tr[u].info;
    int mid = ( tr[u].l + tr[u].r ) >> 1;
    if( r <= mid ) return query( ls, l, r );
    if( mid < l ) return query( rs, l, r );
    return Info::merge( query( ls, l, r ), query( rs, l, r ) );
}

// 线段树二分：查找排名为 k 的权值下标
int find( int u, int k )
{
    if( tr[u].l == tr[u].r ) return tr[u].l;
    if( k <= tr[ls].info.cnt ) return find( ls, k );
    else return find( rs, k - tr[ls].info.cnt );
}

struct Query {
    int opt, x;
} qs[maxn];

vector< int > nums;

int n, m;

int getID( int x ) {
    return lower_bound( nums.begin( ), nums.end( ), x ) - nums.begin( ) + 1;
}

void solve( )
{
    cin >> n;

    for( int i = 1; i <= n; ++ i )
    {
        cin >> qs[i].opt >> qs[i].x;
        // 操作 4 的 x 是排名，不涉及具体数值的操作
        if( qs[i].opt != 4 ) nums.push_back( qs[i].x );
    }

    sort( nums.begin( ), nums.end( ) );
    nums.erase( unique( nums.begin( ), nums.end( ) ), nums.end( ) );

    int m = nums.size( );
    build( 1, 1, m );

    for( int i = 1; i <= n; ++ i )
    {
        auto [opt, x] = qs[i];
        int id = getID( x );

        if( opt == 1 ) {
            modify( 1, id, 1 );
        } else if( opt == 2 ) {
            modify( 1, id, -1 );
        } else if( opt == 3 ) {
            cout << query( 1, 1, id - 1 ).cnt + 1 << '\n';
        } else if( opt == 4 ) { 
            cout << nums[ find( 1, x ) - 1 ] << '\n';
        } else if( opt == 5 ) {
            int cnt = query( 1, 1, id - 1 ).cnt;
            cout << nums[ find( 1, cnt ) - 1 ] << '\n';
        }
        else {
            int cnt = query( 1, 1, id ).cnt;
            cout << nums[ find( 1, cnt + 1 ) - 1 ] << '\n';
        }
    }

}

int main( )
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    solve( );
    return 0;
}
```
{% endfold %}

## 4. 复盘
- **复杂度**: $O( N \log N )$

- **对比分析**：什么时候必须用 Splay 平衡树呢？

	1. **区间翻转/任意切分**（文艺平衡树）：权值线段树维护的是**值**，而 Splay 可以维护**位置**
	2. **LCT**，Splay 是实现 LCT 的辅助树。
	3. 完全在线且无法离散化：那就没法动态开点线段树，只能使用 Splay 的动态节点。

- **碎碎念**: 写权值线段树只是为了巩固对他的认识，不是说一定要用权值线段树解决平衡树问题！

- **关联笔记**: [[线段树]] | [[离散化]] | [[平衡树]]