---
title: '[Leaf] [P3373] [模板] 线段树2'
tags:
  - 数据结构/线段树
  - 难度/P1/提高-
categories:
  - 10_Library
  - 10_数据结构
  - 11_树形结构
abbrlink: 8e4a570d
date: 2026-01-28 00:00:00
---
# [P3373 【模板】线段树 2 - 洛谷](https://www.luogu.com.cn/problem/P3373)

## 1. 题面梗概

**中译中**: 维护一个序列，支持区间加、区间乘、区间求和。所有结果对 $M$ 取模。
    
## 2. 逻辑推导

模板题：考虑到这题有**加**和**乘**两个运算，所以我们的懒标记至少需要存储两个变量 `add` 和 `mul`。

考虑前后计算逻辑：$V_{cur} = V_{old} \times mul + \times len$，即**先乘后加**。

1. 假设当前操作为 乘 K：
	
	- $(V_{old} \times mul + add \times len) \times K = V_{old} \times (mul \times K) + (add \times K) \times len$
	- `mul -> mul * k; add -> add * k`。

2. 假设当前操作为 加 K：

	- $(V_{old} \times mul + add \times len) + K \times len = V_{old} \times mul + (add + K) \times len$
	- `mul -> mul; add -> add + k`。

## 3. 代码实现 #模板

{% fold info @AcCode %}
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int maxn = 1e5 + 5;
ll mod;

struct Tag {
    ll mul = 1, add = 0;
    bool empty( ) { return mul == 1 && add == 0; }
    void clear( ) { mul = 1, add = 0; }
    void apply( const Tag& t ) {
        mul = (mul * t.mul) % mod;
        add = (add * t.mul + t.add) % mod;
    }
};

struct Info {
    ll sum = 0, len = 0;
    static Info merge( const Info& l, const Info& r ) {
        return { (l.sum + r.sum) % mod, l.len + r.len };
    }
    void update( const Tag& t ) {
        sum = (sum * t.mul + t.add * len) % mod;
    }
};

struct Node {
    int l, r;
    Info info;
    Tag tag;
} tr[ maxn << 2 ];

int n, q;
ll a[maxn];

#define ls (u << 1)
#define rs (u << 1 | 1)

void push_up( int u ) {
    tr[u].info = Info::merge( tr[ls].info, tr[rs].info );
}

void push_down( int u ) 
{
    if( tr[u].tag.empty( ) ) return;
    tr[ls].info.update( tr[u].tag );
    tr[rs].info.update( tr[u].tag );
    tr[ls].tag.apply( tr[u].tag );
    tr[rs].tag.apply( tr[u].tag );
    tr[u].tag.clear( );
}

void build( int u, int l, int r )
{
    tr[u].l = l, tr[u].r = r;
    tr[u].tag.clear( );
    if( l == r )
    {
        tr[u].info = { a[l], 1 };
        return;
    }
    int mid = (l + r) >> 1;
    build( ls, l, mid );
    build( rs, mid + 1, r );
    push_up( u );
}

void modify( int u, int l, int r, const Tag& t )
{
    if( l <= tr[u].l && tr[u].r <= r )
    {
        tr[u].info.update( t );
        tr[u].tag.apply( t );
        return;
    }
    push_down( u );
    int mid = (tr[u].l + tr[u].r) >> 1;
    if( l <= mid ) modify( ls, l, r, t );
    if( mid < r ) modify( rs, l, r, t );
    push_up( u );
}

ll query( int u, int l, int r )
{
    if( l <= tr[u].l && tr[u].r <= r )
    {
        return tr[u].info.sum;
    }
    push_down( u );
    int mid = (tr[u].l + tr[u].r) >> 1;
    ll res = 0;
    if( l <= mid ) res = (res + query( ls, l, r )) % mod;
    if( mid < r ) res = (res + query( rs, l, r )) % mod;
    return res;
}

void solve( )
{
    cin >> n >> q >> mod;

    for( int i = 1; i <= n; ++ i ) cin >> a[i];
    build( 1, 1, n );

    for( int i = 1; i <= q; ++ i )
    {
        int opt, x, y;
        ll k;
        cin >> opt >> x >> y;
        if( opt == 1 ) 
        {
            cin >> k;
            modify( 1, x, y, Tag{ k, 0 } );
        }
        else if( opt == 2 )
        {
            cin >> k;
            modify( 1, x, y, Tag{ 1, k } );
        }
        else
        {
            cout << query( 1, x, y ) << '\n';
        }
    }
}

int main( )
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int _t = 1;
    // cin >> _t;
    while( _t -- )
    {
        solve( );
    }
    return 0;
}
```
{% endfold %}

## 4. 复盘
- **复杂度**: $O( ( n + q ) \log n )$。
    
- **碎碎念**: 标准乘法 + 加法 的线段树模板。
        
- **关联笔记**: [[线段树]]