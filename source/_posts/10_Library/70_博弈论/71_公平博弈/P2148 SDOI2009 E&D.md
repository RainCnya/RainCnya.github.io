---
title: '[Leaf] P2148 [SDOI2009] E&D'
tags:
  - 博弈论/找规律
  - 难度/P2/省选-
categories:
  - 10_Library
  - 70_博弈论
  - 71_公平博弈
abbrlink: e6cdd83f
date: 2026-01-04
---
    
# [P2148 [SDOI2009] E&D](https://www.luogu.com.cn/problem/P2148 "null")

## 1. 核心逻辑

- **模型抽象**: 若干对独立石子 $(a, b)$，操作为拆分一堆并删掉另一堆。
    
- **破局路径**:
    
    1. **识别独立性**: 每一对石子是一个独立的子游戏，全局胜负由其 SG 值的异或和决定。
        
    2. **打表突破**: 状态 $(a, b)$ 的 SG 函数转移涉及 $\sum_{i+j=a} SG(i, j)$，直接计算复杂度爆炸。手动打表小规模 $SG(a, b)$。
        
    3. **规律识别**:
        
        - 打表发现 $SG(a, b)$ 的值与 $(a-1) \text{ | } (b-1)$ 的二进制结构高度相关。
            
        - 物理规律：$SG(a, b)$ 等于 $(a-1) \text{ | } (b-1)$ 从低位开始连续的 $1$ 的个数。
            
    4. **数学验证**: $(x-1) \text{ | } (y-1)$ 之后，其最低位的 $0$ 的位置即为 SG 值。
        

## 2. 代码实现

{% fold info @AcCode %}

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int maxn = 2e5 + 5;

int get_SG( int x, int y )
{
    int v = ( x - 1 ) | ( y - 1 );
    int cnt = 0;
    while( v & 1 )
    {
        cnt ++;
        v >>= 1;    
    }
    return cnt;
}

void solve( )
{
    int n;
    cin >> n;

    int xor_sum = 0;

    for( int i = 1; i <= n / 2; ++ i )
    {
        int a, b;
        cin >> a >> b;
        xor_sum ^= get_SG( a, b );
    }
    
    if( xor_sum == 0 ) cout << "NO" << '\n';
    else cout << "YES" << '\n';
}

int main( )
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    
    int _t = 1;
    cin >> _t;
    while( _t -- )
    {
        solve( );
    }
    return 0;
}
```

{% endfold %}

## 3. 复盘

- **复杂度**: $O(T \cdot N \cdot \log(\max V))$。
    
- **灵感反思**: 在博弈论中，“打表”不是投机取巧，而是寻找逻辑坍缩点的科学手段。

- 当 SG 转移规则过于复杂时，数值背后必然隐藏着某种二进制对称性或位运算补丁。
    
- **关联母题**: [[SG 函数]]