---
title: '[Leaf] [P2575] 高手过招'
tags:
  - 数学/博弈/SG函数
  - 数学/博弈/Nim
  - 难度/P3
categories:
  - 220_Library
  - 70_杂项专题
  - 71_公平博弈
abbrlink: fe5029ca
date: 2026-01-04 00:00:00
---
  
# [P2575 高手过招](https://www.luogu.com.cn/problem/P2575 "null")

## 1. 核心逻辑

- **模型抽象**: 20 格棋盘，棋子向右移至首个空格。行与行之间互不干扰。
    
- **双向破局路径**:
    
### 路径 A：万能 SG 搜索 (暴力美学)

- **核心思维**: 既然格子数极小（20），直接使用状态压缩 + 记忆化搜索。
    
- **状态定义**: 二进制位表示棋子分布。
    
- **转移逻辑**: 模拟所有合法移动，利用 MEX 运算求出 SG 值。
    
- **评价**: 该路径屏蔽了规则细节，只要能模拟移动即可求解，是复杂博弈的底层兜底。
    
### 路径 B：阶梯 Nim 映射 (物理降维)

- **核心思维**: 观察棋子移动的本质。棋子右移，实际上是在挤占右侧的“空格”。
    
- **物理映射**:
    
    1. 将右侧边缘看作第 0 层。
        
    2. 将连续的空格块看作“阶梯的层级”。
        
    3. 棋子向右移动过 $k$ 个空格，等价于将 $k$ 个石子从当前层移向下一层。
        
- **结论**: 将空格分段，从右往左数，奇数段的棋子个数即为 Nim 堆的大小。
    
- **评价**: 杀掉了 $2^{20}$ 的搜索复杂度，将博弈坍缩为简单的统计规律。

## 2. 代码实现

### 方案一：SG 记忆化搜索 (推荐初见使用)

{% fold info @AcCode: SG Search %}

```cpp
#include <bits/stdc++.h>
using namespace std;

const int max_mask = ( 1 << 20 ) + 5;
int memo[max_mask];

int calc_SG( int mask )
{
    if( memo[mask] != -1 ) return memo[mask];

    bool vis[25];
    memset( vis, 0, sizeof( vis ) );

    for( int i = 19; i >= 0; -- i )
    {
        if( ( mask >> i ) & 1 )
        {
            int nxt = -1;
            for( int j = i - 1; j >= 0; -- j )
            {
                if( ! ( ( mask >> j ) & 1 ) ) { nxt = j; break; }
            }
            if( nxt != -1 )
            {
                int nxt_mask = mask ^ ( 1 << i ) ^ ( 1 << nxt );
                vis[calc_SG( nxt_mask )] = 1;
            }
        }
    }

    int res = 0;
    while( vis[res] ) res ++;
    return memo[mask] = res;
}
```

{% endfold %}

### 方案二：阶梯 Nim 映射

{% fold info @AcCode: Staircase Nim %}

```cpp
#include <bits/stdc++.h>
using namespace std;

int board[25];

void solve( )
{
    int n, m;
    cin >> n;
    int xor_sum = 0;
    for( int i = 1; i <= n; ++ i )
    {
        cin >> m;
        memset( board, 0, sizeof( board ) );
        for( int j = 1; j <= m; ++ j )
        {
            int p; cin >> p;
            board[p] = 1;
        }

        int cnt = 0;
        int step = 0;
        // 从右往左扫描，识别阶梯层级
        for( int j = 20; j >= 1; -- j )
        {
            if( board[j] ) cnt ++;
            else
            {
                // 偶数位置的“石子”移动到奇数位置等价于 Nim 增加
                if( step % 2 == 1 ) xor_sum ^= cnt;
                step ++;
                cnt = 0;
            }
        }
    }
    cout << ( xor_sum == 0 ? "NO" : "YES" ) << '\n';
}
```

{% endfold %}

## 3. 复盘

- **复杂度比较**: 搜索方案 $O(2^L \cdot L)$ vs 映射方案 $O(N \cdot L)$。
    
- **灵感反思**: 写法 1 是“算力碾压”，写法 2 是“逻辑透视”。

- 在竞赛中，应优先用写法 1 稳拿分数，在算力或空间受限时再通过写法 2 进行维度转换。
    
- **关联母题**: [[Nim 游戏及其变体]]