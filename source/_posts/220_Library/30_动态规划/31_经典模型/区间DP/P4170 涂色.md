---
title: '[Leaf] [P4170] 涂色'
tags:
  - DP/区间
  - 策略/贪心
  - 难度/P4
categories:
  - 220_Library
  - 30_动态规划
  - 31_经典模型
abbrlink: 5af5b988
date: 2025-11-24 00:00:00
updated: 2026-02-03 14:09:07
---
# [P4170 [CQOI2007] 涂色 - 洛谷](https://www.luogu.com.cn/problem/P4170)

## 1. 题面梗概

**中译中**: 一行格子。每次可以把连续一段刷成同一种颜色。问最少刷几次能变成目标图案。

## 2. 逻辑推导

这题显然可以通过区间 DP 来处理，既然是区间 DP，我们不难定义 $f[l][r]$ 为完成区间 $[l,r]$ 的最小涂色次数。

转移也很简单： $f[l][r] = \min_{l \leq k \leq r - 1}(f[l][k] + f[k+1][r])$。

但是问题也很明显，这只是单纯的合并，没有体现涂色动作本身覆盖的特性。

### 2.1 覆盖？

我们考虑一个特殊的情况，若 $s[l] == s[r]$ 呢？这就意味着涂 $l$ 的那次动作中同时可以顺带把 $r$ 也涂成相同的底色，无需代价。

$$
f[l][r] = \min(f[l+1][r], f[l][r-1])
$$

若 $s[l] \neq s[r]$ 呢？那就没法蹭颜色了，老老实实枚举分割点 $k$ 吧。

$$
f[l][r] = \min_{l \leq k \leq r - 1}(f[l][k] + f[k+1][r])
$$

### 2.2 结论

区间 DP 的转移不一定全是 $O(N)$ 的分割，端点的特殊性质往往能提供 $O(1)$ 的状态转移。

## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn = 55;
const int inf = 1e9;

int dp[maxn][maxn];
string s;
int n;

int main()
{	
    cin >> s;
    n = s.length( );
    s = ' ' + s;

    memset( dp, 127, sizeof( dp ) );

    for( int i = 1; i <= n; ++ i )
    {
        dp[i][i] = 1;
    }

    for( int len = 2; len <= n; ++ len )
    {
        for( int l = 1; l + len - 1 <= n; ++ l )
        {
            int r = l + len - 1;
	        // 特殊情况
            if( s[l] == s[r] )
            {
                dp[l][r] = min( dp[l+1][r], dp[l][r-1] );
            }
            else
            {
                for( int k = l; k < r; ++ k )
                {
                    dp[l][r] = min( dp[l][r], dp[l][k] + dp[k+1][r] );
                }
            }
        }
    }

    cout << dp[1][n] << '\n';
    return 0;
}
```

{% endfold %}

## 4. 复盘

- **复杂度**: $O( N^3 )$。
    
- **碎碎念**：这题的关键在于意识到，同色的端点可以在同一次操作中被处理。
        
- **关联笔记**: [[区间DP]]