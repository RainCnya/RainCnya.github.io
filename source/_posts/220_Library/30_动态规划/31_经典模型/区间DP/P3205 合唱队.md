---
title: '[Leaf] [P3205] 合唱队'
tags:
  - DP/区间
  - 策略/逆向思维
  - 难度/P2
categories:
  - 220_Library
  - 30_动态规划
  - 31_经典模型
abbrlink: 73486b1b
date: 2025-11-24 00:00:00
updated: 2026-02-03 15:06:38
---
# [P3205 [HNOI2010] 合唱队 - 洛谷](https://www.luogu.com.cn/problem/P3205)

## 1. 题面梗概

**中译中**: 给定一个理想的身高序列。每个人进场时只能排在当前队伍的最左边或者最右边。

条件如下：如果是从左边进，必须比前一个进场的人矮；如果是从右边进，必须比前一个进场的人高。求总共有多少种进场顺序能构出这个序列。

## 2. 逻辑推导

这道题的难点在于进场顺序是**动态的**，而目标序列是**静态的**。

### 2.1 搜素

我们尝试模拟第一个人是谁，然后搜索第二个人是谁……但这样复杂度不现实。

### 2.2 区间

既然人只能从左右加入，那么对于原来已经成型的部分，它就是个区间，最后一个进场的人只能在 $l$ 或 $r$ 处。

既然如此，我们反向思考，区间 $[l,r]$ 是由谁收尾的。

如果收尾的是 $l$，那么之前就是 $[l+1,r]$；反之如果收尾的是 $r$，那么之前的就是 $[l,r-1]$。

### 2.3 DP

这样就很好写了，可以用区间DP 来递归解决问题。

**状态定义**：$f[l][r][0/1]$ 表示形成 $[l,r]$ 区间，且最后一个人是 $l/0$ 或者 $r/1$ 的情况。

**状态转移**：以 $f[l][r][0]$ 为例：$l$ 进来之前，最后一个人可能是 $l+1$ 或者 $r$。

- 若 $a[l] < a[l+1]$，则可以由 $f[l+1][r][0]$ 转移；
- 若 $a[l] < a[r]$，则可以由 $f[l+1][r][1]$ 转移；

### 2.4 结论

关键在于逆向思维，我们从搜索转化为了逆向的区间扩张。

## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1005;
const int mod = 19650827;

int dp[maxn][maxn][2];
int h[maxn];
int n;

int main()
{	
    cin >> n;
    for( int i = 1; i <= n; ++ i )
    {
        cin >> h[i];
    }

    for( int i = 1; i <= n; ++ i )
    {
        dp[i][i][0] = 1;
    }

    for( int len = 2; len <= n; ++ len )
    {
        for( int l = 1; l + len - 1 <= n; ++ l )
        {
            int r = l + len - 1;

            if( h[l] < h[l+1] ) dp[l][r][0] = ( dp[l][r][0] + dp[l+1][r][0] ) % mod;
            if( h[l] < h[r] ) dp[l][r][0] = ( dp[l][r][0] + dp[l+1][r][1] ) % mod;
            
		    if( h[r] > h[l] ) dp[l][r][1] = ( dp[l][r][1] + dp[l][r-1][0] ) % mod;
            if( h[r] > h[r-1] ) dp[l][r][1] = ( dp[l][r][1] + dp[l][r-1][1] ) % mod;
        }
    }

    cout << ( dp[1][n][0] + dp[1][n][1] ) % mod << '\n';
    return 0;
}
```

{% endfold %}

## 4. 复盘

- **复杂度**: $O( N^2 )$。
    
- **碎碎念**：这种“最后一个人是谁”的逆向思维在区间 DP 中非常通用。[[P5851 Greedy Pie Eaters P]] 这题也是类似。
        
- **关联笔记**: [[区间DP]]