---
title: '[Leaf] [P1063] 能量项链'
tags:
  - DP/区间
  - 算法/环形处理
  - 难度/P2
categories:
  - 220_Library
  - 30_动态规划
  - 31_经典模型
abbrlink: 8102430d
date: 2025-11-25 00:00:00
updated: 2026-02-03 14:32:54
---
# [P1063 [NOIP 2006 提高组] 能量项链 - 洛谷](https://www.luogu.com.cn/problem/P1063)
## 1. 题面梗概

**中译中**: 项链上有 $N$ 个珠子。每个珠子有两个值 $(head, tail)$。第 $i$ 颗的 $tail$ 就是第 $i+1$ 颗的 $head$。

两颗相邻珠子合并，产生的能量 = $head(i) \times tail(i) \times tail(i+1)$。求合并完整个项链能产生的最大能量。

## 2. 逻辑推理

这题是 [[P1880 石子合并]] 的变体，但从数学上看，更像是 矩阵链乘。

### 2.1 区间DP

既然是合并珠子，那么本能地就会想到用区间 DP 来写。

但是这样就会遇到两个问题：

1. 珠子是**环形**的，简单的区间 DP 没法处理端点的合并。 
2. 珠子的 $tail$ 和 $head$ 重合，这就意味着珠子并不是点，而是线段（区间）。

### 2.2 分析

第 $i$ 颗珠子是区间 $[a_i,a_{i+1}]$。合并操作：把区间 $[a_l,a_k]$ 和 区间 $[a_k,a_r]$ 合并，释放能量 $a_l \times a_k \times a_r$，这就等价于**矩阵链乘**模型。 

至于环形的处理很简单，类似线性DP，我们只需要复制一份把长度变成 $2N$ 即可。

### 2.3 DP

- **状态定义**：$f[i][j]$ 表示数字点区间 $[l,r]$ 合并出的最大能量。（包含 $r-l$ 颗珠子）

- **状态转移**：

$$
f[l][r] = \max_{l+1 \leq k \leq r-1}(f[l][k] + f[k][r] + a[l] \times a[k] \times a[r])
$$
### 2.4 结论

本题的难点在于环形处理，不过接触过模型后就不是问题了。

## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 105 * 2;

int dp[maxn][maxn];
int a[maxn];
int n;

int main()
{	
    cin >> n;
    for( int i = 1; i <= n; ++ i )
    {
        cin >> a[i];
        a[i + n] = a[i];
    }

    for( int len = 2; len <= n; ++ len )
    {
        for( int l = 1; l + len - 1 <= 2 * n; ++ l )
        {
            int r = l + len - 1;
            for( int k = l; k < r; ++ k )
            {   // [l, k] -- [k+1, r]
                int cur = a[l] * a[k + 1] * a[r + 1];
                dp[l][r] = max( dp[l][r], dp[l][k] + dp[k+1][r] + cur );
            }
        }
    }

    int ans = 0;
    for( int i = 1; i <= n; ++ i )
    {
        ans = max( ans, dp[i][i + n - 1 ] );
    }
    
    cout << ans << '\n';
    return 0;
}
```

{% endfold %}

## 4. 复盘

- **复杂度**: $O( N^3 )$。
    
- **碎碎念**：珠子合并后的特征值由头尾决定，这和石子合并（特征值是重量和）不同，更像矩阵链乘模型。注意循环中 $len$ 的意义：$len$ 个点代表了 $len-1$ 颗珠子。
        
- **关联笔记**: [[区间DP]]