---
title: '[Leaf] [P1040] 加分二叉树'
tags:
  - DP/区间
  - 搜索/DFS
  - 难度/P3
categories:
  - 220_Library
  - 30_动态规划
  - 31_经典模型
abbrlink: 38f7b3d1
date: 2025-11-24 00:00:00
updated: 2026-02-03 14:21:34
---
# [P1040 [NOIP 2003 提高组] 加分二叉树 - 洛谷](https://www.luogu.com.cn/problem/P1040)

## 1. 题面梗概

**中译中**: 给你一个 1 到 $N$ 的中序遍历序列。现在要你在这个序列的基础上构出一棵二叉树，使得总分最高。

规则：子树分 = 左子树分 $\times$ 右子树分 + 根分。空树算 1 分。求最高分并输出前序遍历。

## 2. 逻辑推理

这题乍一看“树”？那不是树形 DP？但是给定了中序遍历这个限制条件。

### 2.1 树形DP

我们考虑树形 DP 处理？或者尝试 DFS 搜索所有的树的形态？

但是问题来了，我们连树的形状都不知道，怎么定义状态呢？如果要搜索树的状态，状态空间是卡特兰数这个级别的，呵呵。

### 2.2 区间

我们发现题目给定了我们一个中序遍历的序列，而这个序列有一个很特别的性质：**任何一颗子树在中序遍历区间内，必然对应着一个连续的区间**。

而两个区间的中间点，也就是两颗子树的根节点。既然如此，这个题就从树形 DP 转化到了区间 DP 上。

如果我们假设区间 $[l,r]$ 是一颗子树，那么我们可以枚举其中的任意一个点 $k$ 为根，左侧 $[l, k-1]$ 必然是左子树，右侧 $[k+1,r]$ 必然是右子树。

### 2.3 合并

既然子树等价于区间，那么构造树这个操作就转化为了序列上的合并。

**状态定义**：$f[l][r]$ 表示区间 $f[l][r]$ 构成子树能获得的最大的价值。

**状态转移**：

$$
f[l][r] = \max_{l \leq k \leq r}(f[l][k-1] \times f[k+1][r] + a[k])
$$
特判：当子树为空时，即 $l > r$ 时，$f = 1$。

### 2.4 结论

中序遍历序列将复杂的树形转化为了线性的区间问题。

## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn = 50;

long long dp[maxn][maxn];
long long a[maxn];
int root[maxn][maxn];
int n;
bool flag = 0;
vector<int> res;

void init( int l, int r )
{
    if( l > r ) return;
    if( l == r ) 
    {
        res.push_back( l );
        return;
    }
    int k = root[l][r];
    res.push_back( k );
    init( l, k - 1 );
    init( k + 1, r );
}

int main( )
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);

    cin >> n;

    for( int i = 0; i <= n + 1; ++ i )
    {
        for( int j = 0; j <= n + 1; ++ j )
        {
            dp[i][j] = 0;
        }
        dp[i][i-1] = 1;
    }

    for( int i = 1; i <= n; ++ i )
    {
        cin >> a[i];
        dp[i][i] = a[i];
        root[i][i] = i;
    }

    for( int len = 2; len <= n; ++ len )
    {
        for( int l = 1; l + len - 1 <= n; ++ l )
        {
            int r = l + len - 1;
            for( int k = l; k <= r; ++ k )
            {
                long long cur = dp[l][k-1] * dp[k+1][r] + a[k];
                if( cur > dp[l][r] )
                {
                    dp[l][r] = cur;
                    root[l][r] = k;
                }
            }
        }
    }

    cout << dp[1][n] << '\n';
    init( 1, n );

    for( int i = 0; i < n; ++ i )
    {
        cout << res[i];
        if( i != n - 1 ) cout << " ";
    }
    return 0;
}
```

{% endfold %}

## 4. 复盘

- **复杂度**: $O( N^3 )$。
    
- **碎碎念**：空子树必须给 $1$ 分，否则 $0$ 的乘法会很绝望的。再就是题目要输出前序遍历，众所周知，前序+中序可以确定一颗树，所以我们需要重构这棵树，本题中采用 $root[l][r]$ 重构树。
        
- **关联笔记**: [[区间DP]]