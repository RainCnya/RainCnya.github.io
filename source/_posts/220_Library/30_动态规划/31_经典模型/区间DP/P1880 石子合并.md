---
title: '[Leaf] [P1880] 石子合并'
tags:
  - DP/区间
  - 算法/环形处理
  - 算法/前缀差分
  - 难度/P2
categories:
  - 220_Library
  - 30_动态规划
  - 31_经典模型
abbrlink: dd76d016
date: 2025-11-24 00:00:00
updated: 2026-02-03 14:42:47
---
# [P1880 [NOI1995] 石子合并 - 洛谷](https://www.luogu.com.cn/problem/P1880)

## 1. 题面梗概

**中译中**: 环形排列的 $N$ 堆石子。每次选相邻两堆合并，代价是两堆石子的总重量。求合并成一堆的最小代价和最大代价。

## 2. 逻辑推理

这题是 区间DP 的母题，也是处理环形问题的基本模型。

### 2.1 贪心？

第一想法很简单，每次选最小的两堆进行合并，然后肯定就是最小代价了。

但是问题来了！石子只允许相邻的进行合并，单纯的贪心死路一条。接着就是老问题，环形问题。

### 2.2 区间DP

总之，合并的最后一步，一定是左边的一大团，和右边的一大团合并。每一团在原始序列中必然对应着一段连续的区间。

至于环形，我们复制一组序列放在原序列后面即可。

**状态定义**：$f[l][r]$ 表示合并 $[l,r]$ 石子的代价。

**状态转移**：

$$
f[i][j] = \max/\min_{k=i}^{j-1} \{ f[i][k] + f[k+1][j] \} + \sum_{i=l}^{r}a_i
$$
- 其中的 $\sum a_i$ 可以用前缀和 $O(1)$ 预处理。

## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn = 200 + 50;
const int inf = 1e9;

int mindp[maxn][maxn];
int maxdp[maxn][maxn];
long long sum[maxn];
int a[maxn];
int n;

int main( )
{	
    cin >> n;
    for( int i = 1; i <= n; ++ i )
    {
        cin >> a[i];
        a[i + n] = a[i];
    }

    for( int i = 1; i <= n * 2; ++ i )
    {
        sum[i] = sum[i-1] + a[i];
        mindp[i][i] = maxdp[i][i] = 0;
    }

    for( int len = 2; len <= n; ++ len )
    {
        for( int i = 1; i + len - 1 <= 2 * n; ++ i )
        {
            int j = i + len - 1;
            mindp[i][j] = inf;
            maxdp[i][j] = -inf;
            
            int cur = sum[j] - sum[i-1];

            for( int k = i; k < j; ++ k )
            {
                mindp[i][j] = min( mindp[i][j], mindp[i][k] + mindp[k+1][j] + cur );
                maxdp[i][j] = max( maxdp[i][j], maxdp[i][k] + maxdp[k+1][j] + cur );
            }
        }
    }

    int minans = inf, maxans = -inf;
    for( int i = 1; i <= n; ++ i )
    {
        minans = min( minans, mindp[i][i + n - 1] );
        maxans = max( maxans, maxdp[i][i + n - 1] );
    }

    cout << minans << '\n';
    cout << maxans << '\n';
    return 0;
}
```

{% endfold %}

## 4. 复盘

- **复杂度**: $O( N^3 )$。
	
- **碎碎念**:  虽然 $O(N^3)$ 够了，但最小代价可以用四边形不等式优化到 $O(N^2)$，或者用 Garsia-Wachs 算法进一步优化到 $O(N \log N)$，不过最大值不满足那个性质。
        
- **关联笔记**: [[区间DP]] | [[前缀和与差分]]