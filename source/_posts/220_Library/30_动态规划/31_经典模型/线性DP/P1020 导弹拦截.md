---
title: '[Leaf] [P1020] 导弹拦截'
tags:
  - DP/线性
  - DP/线性/Dilworth定理
  - 难度/P3
categories:
  - 220_Library
  - 30_动态规划
  - 31_经典模型
abbrlink: 5e9e3688
date: 2025-11-11 00:00:00
---
# [Luogu-P1020](https://www.luogu.com.cn/problem/P1020) 导弹拦截

## 1. 核心逻辑

- **问题本质**: 求最长不上升子序列（LDS）长度，以及覆盖全集所需的最小 LDS 数量。
    
1. **第一问**: 直接求 LDS 长度。由于 $N$ 较大，需使用 $O(N \log N)$ 贪心二分优化。
	
2. **第二问 (Dilworth 定理)**: 最小链覆盖数 = 最长反链长度。
        
	- “不上升”的反链即为“严格上升”。
            
	- 因此，覆盖所需的最少系统数 $\iff$ 最长上升子序列（LIS）的长度。
            

## 2. 代码实现

{% fold info @AcCode %}

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e5 + 50;
int a[ maxn ], g[ maxn ], n;

int main( ) 
{
    int x;
    while( cin >> x ) a[ ++ n ] = x;

    // 1. 最长不上升子序列 (LDS) -> 贪心
    int len = 0;
    for( int i = 1; i <= n; ++ i ) 
    {
        if( ! len || a[ i ] <= g[ len ] ) g[ ++ len ] = a[ i ];
        else 
        {
            // 找到第一个 < a[i] 的元素替换 (为了非严格单调)
            int pos = upper_bound( g + 1, g + len + 1, a[ i ], greater< int >( ) ) - g;
            g[ pos ] = a[ i ];
        }
    }
    cout << len << "\n";

    // 2. 最少拦截系统数 = 最长上升子序列 (LIS)
    len = 0;
    for( int i = 1; i <= n; ++ i ) 
    {
        if( ! len || a[ i ] > g[ len ] ) g[ ++ len ] = a[ i ];
        else 
        {
            int pos = lower_bound( g + 1, g + len + 1, a[ i ] ) - g;
            g[ pos ] = a[ i ];
        }
    }
    cout << len << "\n";

    return 0;
}
```

{% endfold %}

## 3. 归档备注

- **复杂度**: $O(N \log N)$，瓶颈在于二分查找。
    
- **关键点**: 理解 Dilworth 定理在偏序集上的对偶性，将覆盖问题转换为最长子序列问题。

- **关联知识点**: [[线性DP]] 