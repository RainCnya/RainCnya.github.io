---
title: '[Leaf] [P2516] 最长公共子序列'
tags:
  - DP/线性
  - DP/计数
  - 难度/P4
categories:
  - 220_Library
  - 30_动态规划
  - 31_经典模型
abbrlink: 74f6b4c4
date: 2025-11-13 00:00:00
---
# [Luogu-P2516](https://www.luogu.com.cn/problem/P2516) 最长公共子序列

## 1. 题面梗概

求两个字符串的 LCS 长度及满足该长度的非空子序列方案数。

## 2. 逻辑推导

求方案数，显然是计数 DP 的标志，我们考虑开两个数组分别求 **LCS 长度** 和 **方案数**。

定义：$f[i][j]$：LCS 长度。$g[i][j]$：方案数。

那么状态转移就从 LCS 的推导中同时完成计数，逻辑参考下方代码。

```cpp
if( A[i] == B[j] )
{
	f[i][j] = f[i-1][j-1] + 1;
	g[i][j] = g[i-1][j-1];
}
else
{
	f[i][j] = max( f[i-1][j], f[i][j-1] );
	if( f[i][j] == f[i-1][j] ) g[i][j] += g[i-1][j];
	if( f[i][j] == f[i][j-1] ) g[i][j] += g[i][j-1];
	// 容斥原理
	if( f[i][j] == f[i-1][j-1] ) g[i][j] -= g[i-1][j-1];
}
```
                
> **优化**: 使用滚动数组。
        

## 2. 代码实现

{% fold info @AcCode %}

```cpp
#include <bits/stdc++.h>
using namespace std;

const int mod = 1e8;
const int maxn = 5005;
int f[2][maxn], g[2][maxn];
char s1[maxn], s2[maxn];

int main( ) 
{
    scanf( "%s %s", s1 + 1, s2 + 1 );
    int n = strlen( s1 + 1 )-1; // 题目末尾带点
    int m = strlen( s2 + 1 )-1;

    for( int j = 0; j <= m; ++ j ) g[0][j] = 1;
    g[1][0] = 1;

    int cur = 1, pre = 0;
    for( int i = 1; i <= n; ++ i ) 
    {
        for( int j = 1; j <= m; ++ j ) 
        {
            g[cur][j] = 0;
            if( s1[i] == s2[j] ) 
            {
                f[cur][j] = f[pre][j-1] + 1;
                g[cur][j] = g[pre][j-1];
            }
            else 
            {
                f[cur][j] = max( f[pre][j], f[cur][j-1] );
                if( f[cur][j] == f[pre][j] ) g[cur][j] = ( g[cur][j] + g[pre][j] ) % mod;
                if( f[cur][j] == f[cur][j-1] ) g[cur][j] = ( g[cur][j] + g[cur][j-1] ) % mod;
                if( f[cur][j] == f[pre][j-1] ) g[cur][j] = ( g[cur][j]-g[pre][j-1] + mod ) % mod;
            }
        }
        pre ^= 1; cur ^= 1;
        g[cur][0] = 1; // 每一行开头方案数为 1 (空序列)
        for( int j = 0; j <= m; ++ j ) f[cur][j] = 0;
    }

    printf( "%d\n%d\n", f[pre][m], g[pre][m] );
    return 0;
}
```

{% endfold %}

## 3. 归档备注

- **复杂度**: $O(NM)$ 时间，$O(M)$ 空间。
    
- **关键点**: 注意输入末尾的点号处理。方案数转移时的容斥减法是防止重复计数的关键。

- **关联知识点**: [[线性DP]]