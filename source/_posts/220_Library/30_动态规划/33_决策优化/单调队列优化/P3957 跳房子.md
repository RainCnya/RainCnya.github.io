---
title: '[Leaf] [P3957] 跳房子'
tags:
  - DP/线性
  - DP/优化
  - 算法/单调队列
  - 策略/二分答案
  - 难度/P3
categories:
  - 220_Library
  - 30_动态规划
  - 33_决策优化
abbrlink: 860d8b92
date: 2025-11-7
---
# [Luogu-P3957](https://www.luogu.com.cn/problem/P3957) 跳房子

## 1. 题意梗概

**中译中**：有一个机器人跳格子，初始弹跳距离为 $d$，花 $g$ 个金币可以让弹跳距离变成 $[d-g,d+g]$。每个格子的分数为 $s_i$，距离起点的距离为 $x_i$。

现给定一个 $k$，问最少花多少钱，可以获得至少 $k$ 分。

## 2. 逻辑推导

**第一反应**：花的金币越多，跳跃距离越大（越灵活），能跳到的格子越多，所以最终获得的分数显然是**单调不减**的。

既然有单调性，那我们直接二分金币数 $g$。

**二分逻辑**：

那么问题就来到了怎么构造 check 函数上，考虑跳跃距离在 $[d-g,d+g]$ 的限制下，能不能跳出总和 $\geq k$ 的路径。

那这就变成了一个典型的 DP 优化问题。

**DP 逻辑**：

1. **定义状态**：`dp[i]` 表示跳到第 $i$ 个格子时能获得的最高分数。

2. **状态转移**： $dp_i = s_i + \max(dp_j)$ 其中 $x_i - x_j \in [L,R]$。

3. **复杂度**：数据范围 $n \leq 10^5$，若每次转移都暴力扫描的话，复杂度 $O(N^2)$，套上二分直接爆炸了！！！

**优化方案**：

观察发现，随着 $i$ 的增加，满足条件的候选状态 $j$ 的区间也在**单调向右移动**。 

这就是一个标准的“滑动窗口最值”问题。

我们维护一个单调递减的队列，存放 $dp[j]$ 的值，维护最值即可。

1. **入队**：将所有新进入 $[L,R]$ 区间的 $j$ 加入队列，并保持队列单调递减。
2. **出队**：将所有太靠左的 $j$ 弹出。
3. **统计**：此时队首就是我们需要的 $\max(dp[j])$。
    
## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int maxn = 5e5 + 50;
const ll inf = 1e18;

ll n, d, k;
ll x[maxn], s[maxn];
ll dp[maxn];

bool check( ll g )
{
    ll L = max( 1ll, d - g );
    ll R = d + g;

    for( int i = 1; i <= n; ++ i )
    {
        dp[i] = -inf;
    }
    dp[0] = 0;
    
    deque<int> q;
    int l = 0;

    for( int r = 1; r <= n; ++ r )
    {
	    // 入队
        while( l < r && x[l] <= x[r] - L )
        {
            if( dp[l] != -inf )
            {
                while( !q.empty( ) && dp[ q.back( ) ] <= dp[l] )
                {
                    q.pop_back( );
                }
                q.push_back( l );
            }
            l ++;
        }
		
		// 出队
        while( !q.empty( ) && x[ q.front( ) ] < x[r] - R ) 
        {
            q.pop_front( );
        }
		
		// 统计
        if( !q.empty( ) )
        {
            dp[r] = dp[ q.front( ) ] + s[r];
        }
		
		// 判断
        if( dp[r] >= k ) return 1;
    }
    return 0;
}

int main( ) 
{
    ios::sync_with_stdio( 0 );
    cin.tie( 0 );

    cin >> n >> d >> k;
    for( int i = 1; i <= n; ++ i ) 
    {
        cin >> x[ i ] >> s[ i ];
    }

    int l = 0, r = 1e9, ans = -1;
    while( l <= r ) 
    {
        int mid = ( l + r ) >> 1;
        if( check( mid ) ) ans = mid, r = mid - 1;
        else l = mid + 1;
    }

    cout << ans << "\n";
    return 0;
}
```

{% endfold %}

## 3. 归档备注

- **复杂度**: $O(N \log (dist))$。
    
- **碎碎念**：
	
	- 这题和 [[P1419 寻找段落]] 的区别在于，候选范围是根据 “距离 $x$” 来划定的，所以我们需要双指针处理左边界。
	- **初始化陷阱**：因为格子的价值可能是负数，所以 $dp$ 数组初始化的时候必须设置为极小值 `-inf`。

- **相关知识点**: [[二分体系]] | [[单调栈与队列]] | [[DP优化]]