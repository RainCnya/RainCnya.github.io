---
title: '[Leaf] [P4588] 数学计算'
tags:
  - 数据结构/线段树
  - 数论/同余
  - 难度/P3
categories:
  - 220_Library
  - 10_数据结构
  - 11_树形结构
abbrlink: b43ca25d
date: 2026-01-28 00:00:00
---
# [P4588 [TJOI2018] 数学计算 - 洛谷](https://www.luogu.com.cn/problem/P4588)

## 1. 题面梗概

 **中译中**: 维护一个变量 $x$（初值为 $1$）。有两种操作：一是将 $x$ 乘上一个数 $m$；二是撤销第 $pos$ 次操作所乘的数（即除以那个数）。每次操作后都要输出 $x \bmod M$。
    
 **难点**: 模数 $M$ 不一定是质数，且不保证与乘数互质。这意味着**逆元可能不存在**，直接做除法会卡死。

## 2. 逻辑推导

在模运算前提下，除以一个数最直接的想法就是求解逆元。但 $M$ 不保证为质数，所以我们需要一种不需要逆元也能实现 **撤销** 逻辑的方法。

### 2.1 建模

- 我们可以把 $Q$ 次操作看作是时间轴上的 $Q$ 个节点。
- 操作 1 ：在第 $i$ 个节点放入一个乘数 $m$。
- 操作 2：将第 $pos$ 个节点的乘数变为 $1$。
- 结论：当前的 $x$ 实际上就是这 $Q$ 个节点所有数字的乘积。

### 2.2 线段树

既然如此，这个问题就转化为了一个维护区间乘积，支持单点修改的数据结构问题，我们采用线段树来处理。

## 3. 代码实现

{% fold info @AcCode %}
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int maxn = 2e5 + 5;
ll mod;

struct Info {
    ll prod = 1;
    static Info merge( const Info& l, const Info& r ) {
        return { (l.prod * r.prod) % mod };
    }
};

struct Node {
    int l, r;
    Info info;
} tr[ maxn << 2 ];

#define ls (u << 1)
#define rs (u << 1 | 1)

void push_up( int u ) {
    tr[u].info = Info::merge( tr[ls].info, tr[rs].info );
}

void build( int u, int l, int r )
{
    tr[u].l = l, tr[u].r = r;
    if( l == r )
    {
        tr[u].info = { 1 };
        return;
    }
    int mid = (l + r) >> 1;
    build( ls, l, mid );
    build( rs, mid + 1, r );
    push_up( u );
}

void modify( int u, int pos, ll val )
{
    if( tr[u].l == tr[u].r )
    {
        tr[u].info.prod = val % mod;
        return;
    }
    int mid = (tr[u].l + tr[u].r) >> 1;
    if( pos <= mid ) modify( ls, pos, val );
    else modify( rs, pos, val );
    push_up( u );
}

void solve( )
{
    int Q;
    cin >> Q >> mod;
    build( 1, 1, Q );

    for( int i = 1; i <= Q; ++ i )
    {
        ll op, v;
        cin >> op >> v;
        if( op == 1 ) modify( 1, i, v );
        else modify( 1, v, 1 );
        cout << tr[1].info.prod << '\n';
    }

}

int main( )
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int _t = 1;
    cin >> _t;
    while( _t -- )
    {
        solve( );
    }
    return 0;
}
```
{% endfold %}

## 4. 复盘

- **复杂度**:  $O( Q \log Q )$。
    
- **碎碎念**: 这题的关键在于把除法转换成抹除历史操作。它不仅避开了逆元，还将动态的问题转化为了静态区间上的单点修改。
        
- **关联笔记**: [[线段树]] | [[乘法逆元体系]]