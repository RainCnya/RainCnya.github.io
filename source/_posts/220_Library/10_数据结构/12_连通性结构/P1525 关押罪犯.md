---
title: 'P1525 [NOIP2010] 关押罪犯'
tags:
  - 数据结构/并查集
  - 策略/贪心
  - 难度/P3
categories:
  - 220_Library
  - 10_数据结构
  - 12_连通性结构
abbrlink: d06e55a1
date: 2025-11-28 00:00:00
---
# [Luogu-P1525](https://www.luogu.com.cn/problem/P1525) 关押罪犯

## 1. 题意梗概

**中译中**：给定两个监狱，一堆罪犯，两两仇恨。我们需要给他们分配牢房，目的是让同一个监狱中**冲突值最大**的一对**尽可能小**。

## 2. 逻辑推导

**直觉**：既然要让最大值最小，那么简单贪心，肯定是把冲突值最大的几个人分开。

接着发现，这其实是一个**二分图判定**的变体。如果我们把所有人分成两边，刚好每一边里没有冲突，那么答案就是 $0$ 。

**贪心起手**：将**冲突值降序**排序，每次处理一对 $(u, v)$，若没法分开（即他们已经在同一个监狱了），那这就是答案。

问题来了——怎么维护这种 冲突 的**对立关系**呢？很简单，我们选择采用**扩展域并查集**。

### 2.1 扩展域并查集

简要提一下思路：

- 开两倍大小的并查集。给每个罪犯 $i$ 虚拟出一个对手集合 $i + n$。
- 若 $u, v$ 有仇，就 `merge( u, v + n ); merge( v, u + n );`。
- 如果 `find( u ) == find( v );` 就说明两者在同一个监狱里。

## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn = 2e4 + 50;
const int maxm = 1e5 + 50;

struct Edge{
    int u, v;
    int cost;
};

Edge a[maxm];
int fa[maxn << 1];
int n, m;

bool cmp( Edge a, Edge b )
{
    return a.cost > b.cost;
}

void init( int _n )
{
    for( int i = 1; i <= _n; ++ i )
        fa[i] = i;
}

int find( int x )
{
    if( fa[x] == x ) return x;
    else return fa[x] = find( fa[x] );
}

void merge( int x, int y )
{
    int fx = find( x );
    int fy = find( y );
    fa[fx] = fy;
}

bool check( int x, int y )
{
    int fx = find( x );
    int fy = find( y );
    return fx == fy;
}

int main( )
{	
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);

    cin >> n >> m;
    
    init( n * 2 );

    for( int i = 1; i <= m; ++ i )
    {
        cin >> a[i].u >> a[i].v >> a[i].cost;
    }

    sort( a + 1, a + m + 1, cmp );

    for( int i = 1; i <= m; ++ i )
    {
        auto [u, v, c] = a[i];
        if( check( u, v ) )
        {
            cout << c;
            return 0;
        }
        else
        {
            merge( u + n, v );
            merge( u, v + n );
        }
    }
    cout << 0;
    return 0;
}
```

{% endfold %}

## 4. 复盘

- **复杂度**: $O( M \log M + M \alpha(N) )$。
    
- **碎碎念**: 扩展域并查集其实是在并查集上，跑二分图染色，这种写法在处理**对立关系**的时候很好用。只要两个点在并查集中相连，就意味着它们属于同一个逻辑集合（比如必须在同一监狱）。
    
- **关联笔记**: [[并查集]] | [[二分图染色]]