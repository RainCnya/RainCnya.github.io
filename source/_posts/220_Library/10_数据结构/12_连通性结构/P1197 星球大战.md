---
title: '[Leaf] [P1197] [JSOI2008] 星球大战'
tags:
  - 数据结构/并查集
  - 策略/逆向思维
  - 难度/P3
categories:
  - 220_Library
  - 10_数据结构
  - 12_连通性结构
abbrlink: 3417472e
date: 2025-11-28 00:00:00
---
# [Luogu-P1197](https://www.luogu.com.cn/problem/P1197) 星球大战

## 1. 题面梗概

**中译中**: 给定一张图，敌人炸掉某些节点。每炸一个，问你还剩下多少个连通块。

## 2. 逻辑推导

**直觉**：第一反应是**动态维护**，但是每炸掉一个节点就意味着分裂，而分裂通常不好处理。

从连通块角度入手，很容易能想到并查集这个数据结构去维护，但它的优势在于 **合并**，而不是**分裂**。

等等，合并和分裂不是逆过程吗？那我们时光倒流好了，反过来重建。

我们先跳过所有的爆炸，看看最后的图长成什么样子，此时只剩下没被炸的点和它们之间的边。

接着我们从最后一次爆炸开始，把点一个一个修回来。

**结论**：我们把**动态删点**问题转换为了**动态加边**问题。

## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn = 4e5 + 50;

vector< int > adj[maxn];
bool broken[maxn];
int ans[maxn];
int ks[maxn];
int fa[maxn];
int n, m, k;
int total;

void DsuInit( int _n )
{
    for( int i = 1; i <= _n; ++ i ) 
    {
        fa[i] = i;
    }
}

int find( int x )
{
    if( fa[x] == x ) return x;
    return fa[x] = find( fa[x] );
}

void merge( int x, int y )
{
    int rx = find( x ), ry = find( y );
    if( rx != ry )
    {
        fa[rx] = ry;
        total --;
    }
}

int main( )
{	
    cin >> n >> m;

    DsuInit( n );

    for( int i = 1; i <= m; ++ i )
    {
        int u, v;
        cin >> u >> v;
        u ++, v ++;
        adj[u].push_back( v );
        adj[v].push_back( u );
    }

    cin >> k;
    for( int i = 1; i <= k; ++ i )
    {
        cin >> ks[i];
        ks[i] ++;
        broken[ ks[i] ] = 1;
    }

    total = n - k;
    for( int u = 1; u <= n; ++ u )
    {
        if( broken[u] ) continue;
        for( int v : adj[u] )
        {
            if( broken[v] ) continue;
            merge( u, v );
        }
    }

    ans[k + 1] = total;
    for( int i = k; i >= 1; -- i )
    {
        int u = ks[i];
        broken[u] = 0;
        total ++;
        for( int v : adj[u] )
        {
            if( broken[v] ) continue;
            merge( u, v );
        }
        ans[i] = total;
    }

    for( int i = 1; i <= k + 1; ++ i )
    {
        cout << ans[i] << '\n';
    }
    return 0;
}
```

{% endfold %}

## 4. 复盘

- **复杂度**: $O( ( n + m + k ) \alpha(n) )$。
    
- **碎碎念**: 以后看到**删点/删边**并询问**连通性**，可以采取时光倒流的视角试试能不能倒着转化问题。
        
- **关联笔记**: [[并查集]]

