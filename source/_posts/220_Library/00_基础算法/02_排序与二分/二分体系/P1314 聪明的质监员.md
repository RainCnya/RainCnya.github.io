---
title: '[Leaf] [P1314] 聪明的质监员'
tags:
  - 策略/二分答案
  - 算法/前缀差分
  - 难度/P3
categories:
  - 220_Library
  - 00_基础算法
  - 02_排序与二分
abbrlink: 95acfff3
updated: 2026-1-23
date: 2025-10-31 00:00:00
---
# [Luogu-P1314](https://www.luogu.com.cn/problem/P1314) 聪明的质监员

## 1. 题面梗概

**中译中**：给定一组 $n$ 个矿石，每个矿石有重量 $w_i$，价值 $v_i$；$m$ 个检验区间，以及一个标准值 $s$，目标是通找出一个 $W$，使得 $|s - y|$ 最小。

$$
y = \sum_{i=1}^{m}y_i = \sum_{i=1}^{m}\left[ \sum_{j=l_i}^{r_i}[w_j \geq W] \times \sum_{j=l_i}^{r_i}[w_j \geq W] v_j  \right]
$$
什么意思呢？就是 $m$ 个区间里，所有 $w_j \geq W$ 的矿石价值总和。

## 2. 逻辑推导
### 2.1 基本推导

注意到：$[w_j \geq W]$ 告诉我们，$W$ 设置的越高，最终入选的矿石数量就越少。

这意味着 $y$ 的取值是随着 $W$ 增大而减小的——**单调性**。

这又是一个单调性问题，我们可以从**二分答案**入手。同样涉及到区间修改，我们考虑**差分/前缀和**优化复杂度。

### 2.2 二分答案

在这一题中，我们要二分的就是这个 $W$ 取值。 $0 \leq W \leq \max(w_i) + 1$。

接着我们考虑构造 check 函数，目标是通过 $W$ 高效计算 $Y$。

我们从柿子入手 $y = \sum_{i=1}^{m}\left[ \sum_{j=l_i}^{r_i}[w_j \geq W] \times \sum_{j=l_i}^{r_i}[w_j \geq W] v_j  \right]$。

发现其实 $y_i = cnt_i \times sumv_i$，$cnt_i$ 表示个数，$sumv_i$ 表示价值总和。

那这就是两个前缀和数组，提前预处理即可快速计算 $y$ 了。

## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int maxn = 2e5 + 50;
const ll inf = 1e18;

ll w[maxn], v[maxn], L[maxn], R[maxn];
ll cnt[maxn], sumv[maxn];
int n, m;
ll s;

ll check( ll W )
{
    memset( cnt, 0, sizeof( cnt ) );
    memset( sumv, 0, sizeof( sumv ) );

    for ( int i = 1; i <= n; ++ i )
    {
        cnt[i] = cnt[i-1];
        sumv[i] = sumv[i-1];
        if ( w[i] >= W )
        {
            cnt[i] += 1;
            sumv[i] += v[i];
        }
    }
    
    ll Y = 0;
    for ( int i = 1; i <= m; ++ i )
    {
        Y += ( cnt[R[i]] - cnt[L[i] - 1] ) * ( sumv[R[i]] - sumv[L[i] - 1] );
    }
    return Y;
}

int main( )
{
    ios::sync_with_stdio( 0 );
    cin.tie( 0 );

    cin >> n >> m >> s;
    ll max_w = 0;
    for( int i = 1; i <= n; ++ i )
    {
        cin >> w[i] >> v[i];
        max_w = max( max_w, w[i] );
    }

    for( int i = 1; i <= m; ++ i ) 
    {
        cin >> L[i] >> R[i];
    }

    ll l = 0, r = max_w + 1;
    ll ans = inf;

    while( l <= r )
    {
        ll mid = l + ( ( r - l ) >> 1 );
        ll res = check( mid );
        ans = min( ans, abs( res - s ) );
        
        if( res > s ) l = mid + 1;
        else r = mid - 1;
    }

    cout << ans << "\n";
    return 0;
}
```

{% endfold %}

## 3. 复盘

- **复杂度**: $O((N+M) \log W)$。
    
- **碎碎念**: 同样是**前缀和**+**二分答案**的经典例题。这题不难，不要被那个柿子和题目背景吓到了！

- **关联知识点**：[[二分体系]] | [[前缀和与差分]]