---
title: '[Leaf] [P1419] 寻找段落'
tags:
  - 策略/二分答案
  - 算法/单调队列
  - 策略/二分答案/分数规划
  - 难度/P3
categories:
  - 220_Library
  - 00_基础算法
  - 02_排序与二分
abbrlink: 5c9bbb8b
updated: 2026-1-23
date: 2025-11-07 00:00:00
---
# [Luogu-P1419](https://www.luogu.com.cn/problem/P1419) 寻找段落

## 1. 题意梗概

**中译中**：给一个长度为 $n$ 的序列，找一段长度在$[S,T]$ 之间的连续区间，求平均值最大的区间。

## 2. 逻辑推导

### 2.1 基础推导

第一反应：平均值？区间长度不确定，感觉好像没有什么切入点。

但是我们可以假设一下，最终的平均值为 $x$，那么必然有一个区间 $[l,r]$ 是满足条件的：

$$
\frac{\sum_{i=l}^{r}a_i}{r-l+1} \geq x \implies \sum_{i=l}^r a_i \ge x \times (r - l + 1)
$$
如果把 $x$ 移项到左边呢？

$$
\sum_{i=l}^{r}(a_i-x) \geq 0
$$

那这就是一个判断性问题了，我们转化为了二分答案这个 $x$。

### 2.2 二分答案

**前缀和优化**：假设 $b_i = a_i - x$，$S_i$ 为其前缀和。我们需要找到一组 $l,r$ 使得 $S_r - S_l \geq 0$，且 $S \leq r - l \leq T$。

如果我们固定 $r$ 点，那就是在 $[r-T,r-S]$ 区间中找到一个最小的 $S_i$，只要 $S_r - S_i \geq 0$，这个 $x$ 就是合法的。

**滑动窗口**：在一个滑动的窗口 $[r-T,r-S$ 区间中找最小值，这就需要用到单调队列维护最值了。

## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e6 + 50;
const double inf = 1e9;

int n, s, t;
double sum[maxn];
double a[maxn];

bool check( double mid )
{
    sum[0] = 0;
    for( int i = 1; i <= n; ++ i )
    {
        sum[i] = sum[i - 1] + ( a[i] - mid );
    }
    
    deque<int> q;
    for( int i = s; i <= n; ++ i )
    {
	    // 入队
        while( !q.empty( ) && sum[ q.back( ) ] >= sum[i - s] )
            q.pop_back( );
        q.push_back( i - s );
        
		// 出队
        while( !q.empty( ) && q.front( ) < i - t )
            q.pop_front( );
	    
	    // 统计
        if( !q.empty( ) && sum[i] - sum[ q.front( ) ] >= 0 )
            return 1;
    }
    return 0;
}

int main( )
{	
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);

    cin >> n >> s >> t;

    double l = inf, r = -inf;
    for( int i = 1; i <= n; ++ i )
    {
        cin >> a[i];
        l = min( l, a[i] );
        r = max( r, a[i] );
    }
	
	// 实数二分
    double ans = 0;
    for( int k = 1; k <= 100; ++ k )
    {
        double mid = ( r + l ) / 2.0;
        if( check( mid ) ) ans = mid, l = mid;
        else r = mid;
    }
	
    cout << fixed << setprecision(3) << ans << '\n';
    return 0;
}
```

{% endfold %}

## ## 3. 复盘

- **复杂度**: $O(N \times \log V)$。

- **碎碎念**：这是一道很典型的 **0/1 分数规划** 模型。采取前缀和+单调队列+二分答案，还是比较有难度的。
    
- **关联知识点**：[[二分体系]] | [[单调栈与队列]] | [[前缀和与差分]]