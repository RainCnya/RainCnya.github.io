---
title: '[Leaf] [P3143] Diamond Collector S'
tags:
  - 算法/双指针
  - 难度/P2
categories:
  - 220_Library
  - 00_基础算法
  - 01_降维技巧
abbrlink: d3cfec79
date: 2025-11-4
---
# [Luogu-P3143](https://www.luogu.com.cn/problem/P3143) Diamond Collector S

## 1. 核心逻辑

- **问题本质**: 在有序序列中选出两个不相交的区间，使每个区间极差 $\le K$ 且点数之和最大。
    
- **破局转换**:
    
    1. **排序不变量**: 极差限制 $\max - \min \le K$ 在排序后转化为端点差 $a[R] - a[L] \le K$。
        
    2. **维度分解**:
        
        - 利用双指针预处理出以每个位置 $i$ 为右端点的最大区间长度 $len[i]$。
            
        - **前缀最大值**: `pre[i]` 表示前 $i$ 个元素中能选出的最大单区间。
            
        - **后缀最大值**: `suf[i]` 表示从第 $i$ 个元素开始往后能选出的最大单区间。
            
    3. **枚举断点**: 最终结果为 $\max_{1 \le i < N} (pre[i] + suf[i+1])$，确保区间不相交。
        

## 2. 代码实现

{% fold info @AcCode %}

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 5e4 + 50;
int n, k, a[ maxn ], pre[ maxn ], suf[ maxn ];

int main( )
{
    ios::sync_with_stdio( 0 );
    cin.tie( 0 );

    cin >> n >> k;
    for( int i = 1; i <= n; ++ i ) cin >> a[ i ];
    sort( a + 1, a + n + 1 );

    // 1. 正向扫描维护前缀最优
    int L = 1;
    for( int R = 1; R <= n; ++ R )
    {
        while( a[ R ] - a[ L ] > k ) ++ L;
        pre[ R ] = max( pre[ R - 1 ], R - L + 1 );
    }

    // 2. 反向扫描维护后缀最优
    int r_ptr = n;
    for( int l_ptr = n; l_ptr >= 1; -- l_ptr )
    {
        while( a[ r_ptr ] - a[ l_ptr ] > k ) -- r_ptr;
        suf[ l_ptr ] = max( suf[ l_ptr + 1 ], r_ptr - l_ptr + 1 );
    }

    int ans = 0;
    for( int i = 1; i < n; ++ i )
    {
        ans = max( ans, pre[ i ] + suf[ i + 1 ] );
    }

    cout << ans << "\n";
    return 0;
}
```

{% endfold %}

## 3. 归档备注

- **思想渗透**: 这是一个典型的“将全局最优拆分为局部最优组合”的问题，前后缀 DP 是解决“不相交两个区间”问题的标准算子。

- **关联知识点**：[[双指针]]