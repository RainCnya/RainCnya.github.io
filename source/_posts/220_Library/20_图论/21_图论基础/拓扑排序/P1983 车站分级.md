---
title: '[Leaf] [P1983] 车站分级'
tags:
  - 图论/拓扑排序
  - 图论/建模
  - 难度/P3
categories:
  - 220_Library
  - 20_图论
  - 21_图论基础
abbrlink: 95cb0c88
date: 2026-02-06 16:27:53
---

# [P1983 [NOIP 2013 普及组] 车站分级 - 洛谷](https://www.luogu.com.cn/problem/P1983)

## 1. 题面梗概

**中译中**: 一条铁路线上，有 $1, \dots, n$ 的 $n$ 个火车站。每个火车站都有一个级别，最低为 $1$ 级。

**限制条件**：如果这趟车停靠了 $x$ 站点，则所有从它起点到终点间级别大于等于 $x$ 的都必须停靠。

现给出多趟列车的信息，求全图最少需要划分为多少个级别。

## 2. 逻辑推导

这看起来是一个分层图，或者说是按层遍历，直觉上就会想到用拓扑排序找出这个级别划分。

### 2.1 偏序

其实每一趟车都产生了一组偏序关系。假设 $[L,R]$ 区间中，停靠集合为 $S$，未停靠集合为 $U$，则对于 $\forall u \in U, \forall s \in S$，存在约束条件 $level(u) < level(s)$。

而题目要求的 **最少级别数**，在图论中就等价于求 **DAG 上的最长路径长度**。

### 2.2 建图

那么问题就转化为了拓扑排序，下一个问题是怎么建图呢？暴力建图复杂度应该没关系，但是重边会导致入度膨胀，从而导致拓扑错误。

正好 $N \leq 1000$，我们可以考虑用邻接矩阵来存图，自动去重边。

### 2.3 结论

哎，拓扑排序不难，但是建模真的很麻烦。

## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int maxn = 1000 + 5;
const int maxm = 1000 + 5;

bool edge[maxn][maxn];
int stop[maxn];
bool is_stop[maxn];
int indeg[maxn];
int dep[maxn];
int n, m, s;

void solve( )
{
    cin >> n >> m;
    for( int i = 1; i <= m; ++ i )
    {
        cin >> s;
        for( int j = 1; j <= n; ++ j ) is_stop[j] = 0;
        for( int j = 1; j <= s; ++ j )
        {
            cin >> stop[j];
            is_stop[stop[j]] = 1;
        }

        for( int j = stop[1]; j <= stop[s]; ++ j )
        {
            if( is_stop[j] ) continue;

            for( int k = 1; k <= s; ++ k )
            {
                if( !edge[j][stop[k]] )
                {
                    edge[j][stop[k]] = 1;
                    indeg[stop[k]] ++;
                }
            }
        }
    }

    queue< int > q;
    for( int i = 1; i <= n; ++ i )
    {
        if( indeg[i] == 0 ) 
        {
            q.push( i );
            dep[i] = 1;
        }
    }

    while( !q.empty( ) )
    {
        int u = q.front( );
        q.pop( );

        for( int v = 1; v <= n; ++ v )
        {
            if( edge[u][v] )
            {
                dep[v] = dep[u] + 1;
                indeg[v] --;
                if( indeg[v] == 0 ) q.push( v );
            }
        }
    }

    int ans = 0;
    for( int i = 1; i <= n; ++ i )
    {
        ans = max( ans, dep[i] );
    }
    cout << ans << '\n';
}

int main( )
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    solve( );
    return 0;
}
```

{% endfold %}

## 4. 复盘

- **复杂度分析**：总体 $O(M \cdot N + N^2)$。
        
- **碎碎念 (吐槽)**: 题目没有给出边，但“不停靠”与“停靠”本身就构成了一个隐形的二分层级结构。
    
- **关联笔记**：[[拓扑排序]]