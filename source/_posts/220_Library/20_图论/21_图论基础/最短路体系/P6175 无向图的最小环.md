---
title: '[Leaf] [P6175] 无向图的最小环'
tags:
  - 图论/最短路
  - 图论/最小环
  - 难度/P2
categories:
  - 220_Library
  - 20_图论
  - 21_图论基础
abbrlink: 417ca395
date: 2025-12-01 00:00:00
updated: 2026-02-03 21:31:09
---
# [Luogu-P6175](https://www.luogu.com.cn/problem/P6175) 无向图的最小环

## 1. 核心逻辑

- **问题本质**: 在无向加权图中寻找一个权值和最小的简单环。
    
- **核心切入点**:
    
    1. **Floyd 阶段性**: Floyd 算法在外层循环到 $k$ 时，`d[i][j]` 存储的是仅通过节点 $1 \dots k-1$ 的最短路。
        
    2. **环的构造**: 一个经过 $k$ 且由 $1 \dots k$ 点组成的最小环，可以由 $i \leftrightarrow j$ 的最短路（仅通过 $1 \dots k-1$）加上两条边 $(i, k)$ 和 $(k, j)$ 构成。
        
    3. **更新逻辑**:
        
        - 在使用 $k$ 更新 `d[i][j]` 之前，先枚举 $i, j < k$，计算 `d[i][j] + w[i][k] + w[k][j]`。
            
        - 这样保证了 $i, j, k$ 三点互不相同，且路径不包含 $k$。
            
    4. **约束**: 适用于点数较小（$N \le 100$）的场景。
        

## 2. 代码实现

{% fold info @AcCode %}

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int maxn = 105;
const int inf = 1e9;

ll dis[maxn][maxn];
ll adj[maxn][maxn];
int n, m;

int main( )
{
    cin >> n >> m;

    for( int i = 1; i <= n; ++ i )
    {
        for( int j = 1; j <= n; ++ j )
        {
            if( i == j ) dis[i][j] = adj[i][j] = 0;
            else dis[i][j] = adj[i][j] = inf;
        }
    }

    for( int i = 1; i <= m; ++ i )
    {
        int u, v;
        ll d;
        cin >> u >> v >> d;

        adj[u][v] = min( adj[u][v], d );
        adj[v][u] = min( adj[v][u], d );
        dis[u][v] = min( dis[u][v], d );
        dis[v][u] = min( dis[v][u], d );
    }

    ll ans = inf;
    for( int k = 1; k <= n; ++ k )
    {
        for( int i = 1; i < k; ++ i )
        {
            for( int j = i + 1; j < k; ++ j )
            {
                ll cur = dis[i][j] + adj[i][k] + adj[k][j];
                if( cur < ans ) ans = cur;
            }
        }
        for( int i = 1; i <= n; ++ i )
        {
            for( int j = 1; j <= n; ++ j )
            {
                if( dis[i][k] + dis[k][j] < dis[i][j] )
                {
                    dis[i][j] = dis[i][k] + dis[k][j];
                }
            }
        }
    }

    if( ans == inf ) cout << "No solution." << '\n';
    else cout << ans << '\n';

    return 0;
}
```

{% endfold %}

## 4. 复盘
    
- **复杂度分析**: $O(N^3)$。Floyd 算法的结构性变体。
        
- **碎碎念**:
		
	- 关键在于 Floyd 外层循环 $k$ 的物理意义。在执行第 $k$ 轮松弛前，$dist[i][j]$ 记录的是只经过前 $k-1$ 个点的最短路。
		
	- 此时 $dist[i][j] + w[i][k] + w[k][j]$ 刚好构成一个经过 $k$ 且不重复经过其他点（简单环）的路径。
        
- **关联笔记**: [[最短路体系]]