---
title: '[Leaf] [P1144] 最短路计数'
tags:
  - 图论/最短路
  - 组合/计数
  - 难度/P1
categories:
  - 220_Library
  - 20_图论
  - 21_图论基础
abbrlink: 8b78c35a
date: 2025-12-01 00:00:00
updated: 2026-02-03 21:29:32
---
# [Luogu-P1144](https://www.luogu.com.cn/problem/P1144) 最短路计数

## 1. 核心逻辑

- **问题本质**: 求解无权图（边权均为 1）中起点到各点的最短路径方案数。
    
- **破局转换**:
    
    1. **最短路性质**：最短路构成的结构满足拓扑序。在搜索过程中，如果发现更短路径，则方案数被重置；如果发现等长路径，则方案数累加。
        
    2. **转移方程**：
        
        - 若 $dist[u] + 1 < dist[v]$：则 $dist[v] = dist[u] + 1$，$count[v] = count[u]$。
            
        - 若 $dist[u] + 1 = dist[v]$：则 $count[v] = (count[v] + count[u]) \pmod{mod}$。
            
    3. **实现选择**：由于边权为 1，使用 BFS 即可保证最短性。
        

## 2. 代码实现

{% fold info @AcCode %}

```cpp
#include<bits/stdc++.h>
using namespace std;
using PII = pair<int, int>;

const int maxn = 1e6 + 50;
const int mod = 100003;

vector<int> adj[maxn];
int dist[maxn];
int f[maxn];
int n, m;

void dijkstra( )
{
    memset( dist, 127, sizeof( dist ) );
    dist[1] = 0;
    f[1] = 1;

    priority_queue< PII, vector<PII>, greater<PII> > pq;
    pq.push({ 0, 1 });

    while( !pq.empty( ) )
    {
        auto [d, u] = pq.top( );
        pq.pop( );
        if( d > dist[u] ) continue;

        for( int v : adj[u] )
        {
            if( dist[u] + 1 == dist[v] )
            {
                f[v] = ( f[v] + f[u] ) % mod;
            }
            if( dist[u] + 1 < dist[v] )
            {
                dist[v] = dist[u] + 1;
                f[v] = f[u];
                pq.push({ dist[v], v });
            }
        }
    }
}

int main( )
{	
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);

    cin >> n >> m;
    for( int i = 1; i <= m; ++ i )
    {
        int u, v;
        cin >> u >> v;
        adj[u].push_back( v );
        adj[v].push_back( u );
    }

    dijkstra( );
    for( int i = 1; i <= n; ++ i )
    {
        cout << f[i] << '\n';
    }
    return 0;
}
```

{% endfold %}

## **4. 复盘**:
    
- **复杂度分析**: $O(N + M)$。基于无权图（边权均为 1）的 BFS。
        
- **碎碎念**: 这道题的关键在于，意识到最短路产生的结构满足拓扑序。对于无权图，BFS 第一次搜到某个点时就是最短路，此时 `cnt` 直接承袭前驱；如果之后又搜到了同样步数的状态，就进行累加。这本质上是在最短路构成的 DAG 上跑 DP。
        
- **关联笔记**: [[最短路体系]]