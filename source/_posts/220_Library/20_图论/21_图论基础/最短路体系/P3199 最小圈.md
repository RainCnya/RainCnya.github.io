---
title: '[Leaf] [P3199] 最小圈'
tags:
  - 图论/最短路/负环判定
  - 策略/二分答案/分数规划
  - 难度/P3
categories:
  - 220_Library
  - 20_图论
  - 21_图论基础
abbrlink: a3783e6
date: 2025-12-01 00:00:00
---
# [P3199 [HNOI2009] 最小圈 - 洛谷](https://www.luogu.com.cn/problem/P3199)

## 1. 题面梗概

**中译中**: 给一个有向图，找一个环，使得环上边权的平均值 $\frac{\sum w}{|V|}$ 最小。输出最小值。    

## 2. 逻辑推导

看到这个平均值的模型，我下意识就想到了二分答案，以及0/1分数规划模型。

### 2.1 0/1 分数规划

我们先将不等式变形 $\sum w \leq \lambda \cdot |V| \implies \sum ( w - \lambda ) \leq 0$。 

这就意味着：如果把图中所有边的边权都减去一个 $\lambda$，只要图中存在一个**负环**，那么就说明存在一个平均值更小的方案。

### 2.2 负环判定

既然涉及到负环，那 $Dijkstra$ 就显得很无力了，我们采用 $SPFA$ 来解决这个问题。

而 $DFS$ 版的 $SPFA$ 在存在负环时效率高于 $BFS$，非常适合二分答案的场景。

### 2.3 结论

0/1 分数规划 + 图论的结合。

## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int maxn = 3000 + 5;
const int maxm = 10000 + 5;
const double inf = 1e18;

struct Edge {
    int to;
    double weight;
};

vector< Edge > adj[maxn];
double dist[maxn];
bool vis[maxn];
int n, m;

bool has_neg_cycle( int u, double mid )
{
    vis[u] = true;
    for( auto [v, w] : adj[u] )
    {
        if( dist[v] > dist[u] + w - mid )
        {
            if( vis[v] ) return true;
            dist[v] = dist[u] + w - mid;
            if( has_neg_cycle( v, mid ) ) return true;
        }
    }
    vis[u] = false;
    return false;
}

bool check( double mid )
{
    for( int i = 1; i <= n; ++ i ) 
    {
        dist[i] = 0;
        vis[i] = 0;
    }

    for( int i = 1; i <= n; ++ i )
    {
        if( has_neg_cycle( i, mid ) ) return 1;
    }
    return 0;
}

void solve( )
{
    cin >> n >> m;

    for( int i = 1; i <= m; ++ i )
    {
        int u, v;
        double w;
        cin >> u >> v >> w;
        adj[u].push_back({ v, w });
    }

    double l = -1e7, r = 1e7, ans = 0;
    for( int i = 1; i <= 100; ++ i )
    {
        double mid = ( l + r ) / 2.0;
        if( check( mid ) ) ans = mid, r = mid;
        else l = mid;
    }
    cout << fixed << setprecision(8) << ans << '\n';
}

int main( )
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int _t = 1;
    // cin >> _t;
    while( _t -- ) solve( );
    return 0;
}
```

{% endfold %}

## 4. 复盘

- **复杂度分析**：$O( 100 \cdot kM )$。
    
- **碎碎念**：最短路算法（尤其是负环判定）不仅可以求值，还能作为二分答案的判定器。
    
- **关联笔记**：[[最短路体系]]