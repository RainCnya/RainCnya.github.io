---
title: '[Leaf] [P2515] 软件安装'
tags:
  - 图论/连通性/强连通
  - DP/树形
  - DP/背包
  - 难度/P3
categories:
  - 220_Library
  - 20_图论
  - 23_连通性专题
abbrlink: c6dc69f5
date: 2026-02-07 00:01:23
---

# [P2515 [HAOI2010] 软件安装 - 洛谷](https://www.luogu.com.cn/problem/P2515)

## 1. 题面梗概

**中译中**: 你有 $W$ 的磁盘空间，要安装一些软件。每个软件有重量（空间）和价值。约束条件是：有些软件必须先安装另一个特定软件才能安装。这种依赖关系可能形成环。求在空间限制下能获得的最大价值。

## 2. 逻辑推导

这题有两个切入点。第一个是这个类似背包问题的题设，第二个是这个依赖关系。如果没有环，很简单直接跑树形背包即可，但如果有环呢？

### 2.1 缩点

如果存在一个环，那么这个环上的软件，要么全部安装，要么全部都不装。在图论上，这就是个 SCC，我们可以用 Tarjan 进行缩点。

由于每个点原本最多只能有一个出度，所以缩点后的 DAG 上每个点也最多只有一个父节点。

### 2.2 树上DP

缩完后是个 DAG，但在这题条件下，它大概率会是个树林。

为了方便处理，我们可以建立一个虚拟节点 $0$，让所有入度为 $0$ 的节点都连上它。

这样问题就转化为了在一颗以 $0$ 为根的树上做有依赖的背包 DP。

### 2.3 结论

SCC 缩点 + 树形DP 问题。

## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int maxn = 100 + 5;
const int maxm = 500 + 5;

vector< int > adj[maxn], dag[maxn];
stack< int > st;
int dfn[maxn], low[maxn], timer;
bool in_stack[maxn];
int scc[maxn], scc_cnt;
int fa[maxn], indeg[maxn];
ll val[maxn], scc_val[maxn];
ll wei[maxn], scc_wei[maxn];
ll dp[maxn][maxm];
int n, m;

void dfs( int u )
{
    for( int j = scc_wei[u]; j <= m; ++ j )
    {
        dp[u][j] = scc_val[u];
    }

    for( int v : dag[u] )
    {
        dfs( v );
        for( int j = m; j >= scc_wei[u]; -- j )
        {
            for( int k = 0; k <= j - scc_wei[u]; ++ k )
            {
                dp[u][j] = max( dp[u][j], dp[u][j - k] + dp[v][k] );
            }
        }
    }
}

void tarjan( int u )
{
    dfn[u] = low[u] = ++ timer;
    st.push( u );
    in_stack[u] = 1;
    
    for( int v : adj[u] )
    {
        if( !dfn[v] )
        {
            tarjan( v );
            low[u] = min( low[u], low[v] );
        }
        else if( in_stack[v] )
        {
            low[u] = min( low[u], dfn[v] ); 
        }
    }

    if( low[u] == dfn[u] )
    {
        scc_cnt ++;
        int v;
        do {
            v = st.top( ); st.pop( );
            in_stack[v] = 0;
            scc[v] = scc_cnt;
            scc_val[scc_cnt] += val[v];
            scc_wei[scc_cnt] += wei[v];
        } while( v != u );
    }
}

void solve( )
{
    cin >> n >> m;
    for( int i = 1; i <= n; ++ i ) cin >> wei[i];
    for( int i = 1; i <= n; ++ i ) cin >> val[i];
    for( int i = 1; i <= n; ++ i ) 
    {
        cin >> fa[i];
        if( fa[i] == 0 ) continue;
        adj[fa[i]].push_back( i );
    }

    for( int i = 1; i <= n; ++ i )
    {
        if( !dfn[i] ) tarjan( i );
    }

    for( int u = 1; u <= n; ++ u )
    {
        int v = fa[u];
        if( v == 0 || scc[u] == scc[v] ) continue; 
        dag[scc[v]].push_back( scc[u] );
        indeg[scc[u]] ++;
    }

    for( int i = 1; i <= scc_cnt; ++ i )
    {
        if( indeg[i] == 0 ) dag[0].push_back( i );
    }

    scc_wei[0] = scc_val[0] = 0;
    dfs( 0 );

    cout << dp[0][m] << '\n';
}

int main( )
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    solve( );
    return 0;
}
```

{% endfold %}

## 4. 复盘

- **复杂度分析**：Tarjan: $O(N+M)$ 、树形背包: $O(N \cdot M^2)$。
        
- **碎碎念**：SCC 缩点不仅仅是去环，它能改变整个题目的底层结构（从一般图到森林）。这题的背包合并逻辑挺绕的，尤其是 `j >= scc_wei[u]` 的边界条件。
        
- **关联笔记**：[[SCC 缩点]] | [[树形DP]]