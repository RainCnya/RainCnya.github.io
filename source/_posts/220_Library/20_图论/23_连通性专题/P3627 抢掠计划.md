---
title: '[Leaf] P3627 抢掠计划'
tags:
  - 图论/连通性/强连通
  - 图论/拓扑排序
  - 难度/P3
categories:
  - 220_Library
  - 20_图论
  - 23_连通性专题
abbrlink: 87918e5b
date: 2026-02-07 00:19:32
---

# [P3627 [APIO2009] 抢掠计划 - 洛谷](https://www.luogu.com.cn/problem/P3627)

## 1. 题面梗概

**中译中**: 你是一个强盗，要抢劫城市里的 ATM 机。城市里的路是有向的且可能成环。你可以多次经过某条路或者某个点。你从指定的起点 $S$ 出发，最后必须在众多的终点中选择一个撤退。求你最多能抢到多少钱。

## 2. 逻辑推导

可以重复经过？那不就是环咯，有向图，SCC 缩点先啦。

### 2.1 拓扑DP

缩完点之后这就是个 DAG 求最长路问题。每个 SCC 点维护 `scc_val` 和 `scc_bar`，记录权值和终点。

当然，除了拓扑 DP 求最长路外，也能用 SPFA 跑最长路。

### 2.2 对比 SPFA

如果图中存在环且你想求最长路，那这是一个 NP-Hard 问题（除非环全是负的）。但本题我们已经通过 Tarjan 消除了所有正环（环都缩成点了）。

在 **DAG** 上，拓扑DP 是稳定的 $O(N+M)$，而 SPFA 虽然平均快，但最坏情况是 $O(NM)$。

既然 Tarjan 已经把图变成了 DAG，那么直接跑拓扑 DP 在复杂度是占优的。

## 3. 代码实现

{% fold info @AcCode %}
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int maxn = 5e5 + 50;
const int maxm = 5e5 + 50;

vector< int > adj[maxn], dag[maxn];
stack< int > st;
int dfn[maxn], low[maxn], timer;
bool in_stack[maxn];
int scc[maxn], scc_cnt;
int indeg[maxn];
ll val[maxn], scc_val[maxn];
bool bar[maxn], scc_bar[maxn];
ll dist[maxn];
int n, m;

void tarjan( int u )
{
    dfn[u] = low[u] = ++ timer;
    st.push( u );
    in_stack[u] = 1;
    
    for( int v : adj[u] )
    {
        if( !dfn[v] )
        {
            tarjan( v );
            low[u] = min( low[u], low[v] );
        }
        else if( in_stack[v] )
        {
            low[u] = min( low[u], dfn[v] ); 
        }
    }

    if( low[u] == dfn[u] )
    {
        scc_cnt ++;
        int v;
        do {
            v = st.top( ); st.pop( );
            in_stack[v] = 0;
            scc[v] = scc_cnt;
            scc_val[scc_cnt] += val[v];
            scc_bar[scc_cnt] |= bar[v];
        } while( v != u );
    }
}

void solve( )
{
    cin >> n >> m;
 
    for( int i = 1; i <= m; ++ i )
    {
        int u, v;
        cin >> u >> v;
        adj[u].push_back( v );
    }

    for( int i = 1; i <= n; ++ i ) cin >> val[i];

    int s, p;
    cin >> s >> p;
    
    for( int i = 1; i <= p; ++ i )
    {
        int b;
        cin >> b;
        bar[b] = 1;
    }

    for( int i = 1; i <= n; ++ i )
    {
        if( !dfn[i] ) tarjan( i );
    }

    for( int u = 1; u <= n; ++ u )
    {
        for( int v : adj[u] )
        {
            if( scc[u] == scc[v] ) continue;
            dag[scc[u]].push_back( scc[v] );
            indeg[scc[v]] ++;
        }
    }

    memset( dist, -1, sizeof( dist ) );
    dist[scc[s]] = scc_val[scc[s]];

    queue< int > q;
    for( int i = 1; i <= scc_cnt; ++ i )
    {
        if( indeg[i] == 0 ) q.push( i );
    }

    while( !q.empty( ) )
    {
        int u = q.front( ); q.pop( );
        for( int v : dag[u] )
        {
            if( dist[u] != -1 ) 
            {
                dist[v] = max( dist[v], dist[u] + scc_val[v] );
            }
            indeg[v] --;
            if( indeg[v] == 0 ) q.push( v );
        }
    }

    ll ans = 0;
    for( int i = 1; i <= scc_cnt; ++ i )
    {
        if( scc_bar[i] && dist[i] != -1 ) ans = max( ans, dist[i] );
    }
    
    cout << ans << '\n';
}

int main( )
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    solve( );
    return 0;
}
```
{% endfold %}

## 4. 复盘

- **复杂度分析**：$O(N+M)$。
    
- **碎碎念**：偏商务的打法 —— 拓扑DP，理论上这题不难，只要会 SCC 缩点和拓扑排序，还有DP就行。
	
- **关联笔记**：[[SCC 缩点]] | [[拓扑排序]] | [[最短路体系]]