---
title: '[Leaf] [P5633] 最小度限制生成树'
tags:
  - 图论/生成树
  - 策略/二分答案/WQS二分
  - 难度/P4
categories:
  - 220_Library
  - 20_图论
  - 22_树论专题
abbrlink: daf0e564
date: 2026-02-05 00:00:00
---
# [P5633 最小度限制生成树 - 洛谷](https://www.luogu.com.cn/problem/P5633)

## 1. 题面梗概

**中译中**: 求一棵最小生成树（MST），但有一个限制条件：给定的节点 $s$ 的度数（相连的边数）必须**恰好为** $k$。如果无法构成这样的树，输出 `Impossible`。

## 2. 逻辑推导

这题麻烦的地方就在，节点 $s$ 的度数恰好为 $k$，这就没法用 $Kruskal$ 的朴素贪心了，为了满足度数的要求，我们可能不得不舍弃掉一些便宜的边。

### 2.1 $\Delta$ 凸完全单调性

现在我们有一堆边可以给 $s$ 节点，为了恰好满足 $k$ 个节点，我们可以人为制造这个竞争力。

比如说，我们可以给每条与 $s$ 相连的边增加一个额外成本 $\Delta$。

如果 $\Delta$ 很大，那么 $Kruskal$ 就会避开 $s$ 的边，从而使得 $s$ 的度下降；反之 $s$ 的度就会增加。

既然是单调变化的，我们就可以二分这个 $\Delta$。

### 2.2 WQS二分

我们可以二分一个偏移量 `mid`（即 $\Delta$）。

每次将所有与 $s$ 相连的边权增加 `mid`，然后跑一遍标准 MST。

记录此时 $s$ 的度数 `cnt`，和 $MST$ 的权值 `res`。

若 $cnt \geq k$：则可以尝试增加 $mid$  来减少度数。反之减少 $mid$。

最终答案就是 $res - k \cdot mid$，为什么？因为每条 $s$ 的边都多算了 `mid`。

### 2.3 优化

每次二分都重新排序 $M$ 条边，复杂度会变成 $O(\log W \cdot M \log M)$，效率就很低了。

但是我们可以采用类似**归并排序**的思想，把边分为两组 $A$（与 $s$ 直接相连）， $B$ （其他），提前对 $A, B$ 分别排序。

而因为 $A, B$ 在每次归并之前都是有序的了，所以合并的复杂度就降到了 $O(M)$，太好了，我们干掉了一个 $\log$。

### 2.4 结论

经典的 WQS 二分，不过这题还有别的办法，关于 WQS 二分的具体讲解就不在这篇题解中展开了。

## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int maxn = 5e4 + 50;
const int maxm = 5e5 + 50;
const int inf = 4e4;

struct Edge { int u, v; ll w; int need; } A[maxm], B[maxm], cur[maxm];
bool cmp( const Edge &lhs, const Edge &rhs ) { 
    if( lhs.w != rhs.w ) return lhs.w < rhs.w;
    return lhs.need > rhs.need;
}

int cntA, cntB;
int fa[maxn];
int n, m, s, k;

ll res;
int cnt;

int find( int x )
{
    if( x == fa[x] ) return fa[x];
    else return fa[x] = find( fa[x] );
}

int merge( int u, int v )
{
    int fu = find( u ), fv = find( v );
    if( fu != fv )
    {
        fa[fu] = fv;
        return 1;
    }
    return 0;
}

void merge_sort( int delta )
{
    for( int i = 1; i <= cntA; ++ i ) A[i].w += delta;

    int i = 1, j = 1, kk = 1;

    while( i <= cntA && j <= cntB )
    {
        if( cmp( A[i], B[j] ) ) cur[kk ++] = A[i ++];
        else cur[kk ++] = B[j ++];
    }
    while( i <= cntA ) cur[kk ++] = A[i ++];
    while( j <= cntB ) cur[kk ++] = B[j ++];

    for( int i = 1; i <= cntA; ++ i ) A[i].w -= delta;
    return;
}

bool check( int delta )
{
    merge_sort( delta );
    for( int i = 1; i <= n; ++ i ) fa[i] = i;
    res = cnt = 0;
    for( int i = 1; i <= cntA + cntB; ++ i )
    {
        if( !merge( cur[i].u, cur[i].v ) ) continue;
        cnt += cur[i].need;
        res += cur[i].w;
    }
    return cnt >= k;
}

void solve( )
{
    cin >> n >> m >> s >> k;
    for( int i = 1; i <= m; ++ i )
    {
        int u, v; ll w;
        cin >> u >> v >> w;
        if( u == s || v == s ) A[++ cntA] = { u, v, w, 1 };
        else B[++ cntB] = { u, v, w, 0 };
    }

    sort( A + 1, A + cntA + 1, cmp );
    sort( B + 1, B + cntB + 1, cmp );
    
    if( cntA < k )
    {
        cout << "Impossible" << '\n';
        return;
    }

    for( int i = 1; i <= n; ++ i ) fa[i] = i;

    int block = n;
    for( int i = 1; i <= cntB; ++ i ) block -= merge( B[i].u, B[i].v );

    if( block - 1 > k )
    {
        cout << "Impossible" << '\n';
        return;
    }

    for( int i = 1; i <= cntA; ++ i ) block -= merge( A[i].u, A[i].v );

    if( block != 1 )
    {
        cout << "Impossible" << '\n';
        return;
    }

    int l = -inf, r = inf, ans = -1e9;

    while( l <= r )
    {
        int mid = ( l + r ) >> 1;
        if( check( mid ) ) ans = mid, l = mid + 1;
        else r = mid - 1;
    }

    if( ans == -1e9 )
    {
        cout << "Impossible" << '\n';
        return;
    }

    check( ans );
    cout << res - 1ll * k * ans << '\n';
}

int main( )
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    solve( );
    return 0;
}
```

{% endfold %}

## 4. 复盘

- **复杂度分析**：$O( M \log M + M \log W )$。排序一次，二分中利用归并 $O(M)$ 扫描。
    
- **碎碎念**：这题的 WQS二分 不难，但是它的很多细节很麻烦。。。比如选了 $s$ 全部的边，图是否联通。不算 $s$ 的边剩余连通块数量是否超过 $k$，都很烦。。。对了，注意排序的细节，如果边权相等，优先选择能连上 $s$ 的。
    
- **关联笔记**：[[生成树体系]] | [[WQS  二分]]