---
title: '[Leaf] [P4180] 严格最小生成树'
tags:
  - 图论/生成树
  - 图论/树论/LCA
  - 难度/P4
categories:
  - 220_Library
  - 20_图论
  - 22_树论专题
abbrlink: 6d27c61d
date: 2026-02-05 00:00:00
---

# [P4180 [BJWC2010] 严格次小生成树 - 洛谷](https://www.luogu.com.cn/problem/P4180)

## 1. 题面梗概

**中译中**: 在一张无向图中，找到一棵生成树，使得它的权值和在所有生成树中排第二（严格大于最小生成树 MST 且最小）。

## 2. 逻辑推导

乍一看不就是个 MST 变体吗？求出最小生成树，然后再去掉某一条边，加一条边，使得差值最小不就行了吗？

不对，这样实现起来太麻烦了吧，怎么去找到这一组边呢？

### 2.1 环路替换

次小生成树很简单，在 MST 的基础上，加入一条非树边 $(u, v, w)$，此时图上会出现一个环，我们删掉环上最长的一条边，就可以得到一颗次小生成树。

但是题目要找的是严格最小，那么这一招就不好用了，因为如果加入的边权 $w$ 恰好等于环上最大的边权 $max_1$，那么替换后的权值就不变了，也就不是**严格**次小树了。

既然如此，我们只能退而求其次了，删掉环上严格小于新入边 $w$ 的最大边，也就是环上的**严格次大边** $max_2$。

### 2.2 倍增LCA

那么问题就转化为了，怎么快速查询这个 **严格次大边** 呢？

注意到是树上的 RMQ 问题，我们可以采用倍增 LCA（树上 ST 表）来预处理。

枚举每一条非树边 $(u, v, w)$，查询树上 $u \to v$ 路径间的 $max_1$ 和 $max_2$。

若 $w > max_1$，那么答案就是 $MST\_weight + w - max_1$。
若 $w = max_1$ 且 $max_2$ 存在，那么答案就是 $MST\_weight + w -max_2$。

### 2.3 合并

如何用 ST 表同时维护最大值和次大值呢？

考虑 $Path_a = (max1_a, max2_a)$ 和 $Path_b = (max1_b, max2_b)$ 的合并。

新的 $max_1 = \max(max1_a, max1_b)$。

而新的 $max_2$ 则取自 $(max2_a, max2_b)$，如果 $max1_a \neq max1_b$，则落败的那一方也会参与 $max_2$的更新。

### 2.4 结论

不愧是紫题，其实思路上是不难理解的，但是这个倍增 ST 表不好实现。

## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int maxn = 1e5 + 5;
const int maxm = 3e5 + 5;
const int maxlg = 20;
const ll inf = 1e18;

struct Edge {
    int u, v; ll w;
    bool operator < ( const Edge &oth ) const { return w < oth.w; }
} edges[maxm];

struct Node { int v; ll w; };
vector< Node > adj[maxn];

int up[maxn][maxlg];
ll max1[maxn][maxlg];
ll max2[maxn][maxlg];

int fa[maxn], dep[maxn];
bool is_mst[maxm];
ll mst_weight;
int n, m;

int find( int x ) 
{ 
    if( x == fa[x] ) return fa[x];
    else return fa[x] = find( fa[x] );
}

void dfs( int u, int p, ll w )
{
    dep[u] = dep[p] + 1;
    up[u][0] = p;
    max1[u][0] = w;
    max2[u][0] = -1;
    
    for( int i = 1; i < maxlg; ++ i )
    {
        up[u][i] = up[up[u][i - 1]][i - 1];
        int v1 = max1[u][i - 1], v2 = max1[up[u][i - 1]][i - 1];
        int v3 = max2[u][i - 1], v4 = max2[up[u][i - 1]][i - 1];

        max1[u][i] = max( v1, v2 );
        if( v1 == v2 ) max2[u][i] = max( v3, v4 );
        else max2[u][i] = max( max( v3, v4 ), min( v1, v2 ) );
    }
    
    for( auto& [v, w] : adj[u] )
    {
        if( v == p ) continue;
        dfs( v, u, w );
    }
}

bool kruskal( )
{
    for( int i = 1; i <= n; ++ i ) fa[i] = i;
    sort( edges + 1, edges + m + 1 );

    mst_weight = 0;
    int cnt = 0;

    for( int i = 1; i <= m; ++ i )
    {
        auto [u, v, w] = edges[i];
        int ru = find( u ), rv = find( v );
        if( ru != rv )
        {
            fa[ru] = rv;
            mst_weight += w;
            is_mst[i] = true;
            cnt ++;
            adj[u].push_back( { v, w } );
            adj[v].push_back( { u, w } );
            if( cnt == n - 1 ) break;
        }
    }
    return cnt == n - 1;
}

int get_lca( int u, int v )
{
    if( dep[u] < dep[v] ) swap( u, v );
    int diff = dep[u] - dep[v];

    for( int i = 0; i < maxlg; ++ i )
        if( ( diff >> i ) & 1 ) u = up[u][i];
    
    if( u == v ) return u;
    for( int i = maxlg - 1; i >= 0; -- i )
        if( up[u][i] != up[v][i] )
            u = up[u][i], v = up[v][i];
    
    return up[u][0];
}

void update( ll &m1, ll &m2, ll v1, ll v2 ) 
{
    if( m1 < v1 ) {
        m2 = max( m1, v2 );
        m1 = v1;
    } else if( v1 < m1) {
        m2 = max( m2, v1 );
    } else { 
        m2 = max( m2, v2 );
    }
}

pair< ll, ll > query( int u, int anc )
{
    ll res1 = -1, res2 = -1;
    int diff = dep[u] - dep[anc];
    for( int i = 0; i < maxlg; ++ i )
    {
        if( ( diff >> i ) & 1 ) 
        {
            update( res1, res2, max1[u][i], max2[u][i] );
            u = up[u][i];
        }
    }   
    return { res1, res2 };
}

void solve( )
{
    cin >> n >> m;

    memset( max1, -1, sizeof( max1 ) );
    memset( max2, -1, sizeof( max2 ) );

    for( int i = 1; i <= m; ++ i ) cin >> edges[i].u >> edges[i].v >> edges[i].w;
    
    kruskal( );
    dfs( 1, 0, -1 );

    ll del = inf;
    for( int i = 1; i <= m; ++ i )
    {
        auto [u, v, w] = edges[i];
        if( is_mst[i] || u == v ) continue;

        int lca = get_lca( u, v );

        auto m1 = query( u, lca );
        auto m2 = query( v, lca );

        ll res_m1 = -1, res_m2 = -1;

        update( res_m1, res_m2, m1.first, m1.second );
        update( res_m1, res_m2, m2.first, m2.second );

        if( w > res_m1 ) del = min( del, w - res_m1 );
        else if( res_m2 != -1 ) del = min( del, w - res_m2 );
    }
    
    cout << mst_weight + del << '\n';
}

int main( )
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    solve( );
    return 0;
}
```

{% endfold %}

## 4. 复盘

- **复杂度分析**：$O( M \log M + M \log N )$。
	
- **碎碎念**：这题的代码量好大啊，调试起来一堆有的没的细节，尽可能多拆点函数实现吧，模块化处理会好点。
    
- **关联笔记**：[[生成树体系]] | [[LCA 体系]]
