---
title: '[Leaf] [P2680] 运输计划'
tags:
  - 树论/LCA
  - 算法/前缀差分
  - 策略/二分答案
  - 难度/P4
categories:
  - 220_Library
  - 20_图论
  - 22_树论专题
abbrlink: 248b3a56
date: 2025-11-02 00:00:00
updated: 2026-2-10 21:37:32
---
# [P2680 [NOIP 2015 提高组] 运输计划 - 洛谷](https://www.luogu.com.cn/problem/P2680)

## 1. 题面梗概

**中译中**：一棵 $N$ 的节点的树，树上有 $M$ 条物流路径。现在你可以把树上的一条边直接变成 $0$ 成本，问怎么变能让 “用时最长的那条路径” 尽可能短。

## 2. 逻辑推导

看到这个用时最长的尽可能短，第一反应就是二分答案 $mid$。

简单写个判定函数 `check`，如果我们把所有长度超过 `mid` 的路径都通过删掉一条边降到 `mid` 以下，那这个 `mid` 就是合法的。

### 2.1 转化

既然我们需要用到二分答案，我们就需要高效处理这个 `check` 的判定，总不能每次查询都重新搜一遍吧，那样的复杂度是不能接受的。

对于给定的 `mid`，我们可以将 $M$ 条路径分为两类：

- 第一类 $P_{1}$ 表示长度 $\leq mid$ 的路径，这部分是不需要干涉的。
- 第二类 $P_{2}$ 表示长度 $> mid$ 的路径，这部分是需要我们通过删边解决的。

而既然我们要让所有不满足的边都降到 $mid$ 以下，那么我们要删的边，就必须满足以下两个条件：

- 这条边必须被所有 $P_{2}$ 中的路径同时经过，不然就有漏网之鱼不满足。
- 这条边同时权值比较大，使得最长路径减去它的权值 $w$ 能 $\le mid$。

### 2.2 边差分

这第二个条件很好维护，但问题是第一个条件，我们要如何高效找到 $P_{2}$ 中的所有重复边呢？

如果给每条路径经过的边计数，$O(M \cdot N)$ 显然会炸。

既然路径是一条连续的链，我们不妨对边进行差分，对于每一条路径 $(u, v)$，标记 `diff[u] += 1; diff[v] += 1; diff[lca] -= 2;`。

注意，这里我们把边转换到点上了，由于树上每个点只有一个父节点，所以我们把这条边给到儿子计数。

然后差分完再做一次前缀和，就可以快速确定有哪些边了。

### 2.3 结论

这是一道 **二分答案** + **LCA** + **树上差分** 的经典题目，同时要注意理解点差分和边差分的区别。

## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int maxn = 3e5 + 50;
const int maxlg = 20;

struct Edge { int v, w; };
vector<Edge> adj[maxn];

int up[maxn][maxlg], dep[maxn];
int dist[maxn], edgew[maxn];

struct Path { int u, v, lca, len; } p[maxn];
int diff[maxn], sum[maxn];
int max_len, max_edge, max_weight;
int n, m;

int read( )
{
    int x = 0, f = 1;
    char ch = getchar( );
    while( ch < '0' || ch > '9' ) { if( ch == '-' ) f = -1; ch = getchar( ); }
    while( ch >= '0' && ch <= '9' ) { x = x * 10 + ch - '0'; ch = getchar( ); }
    return x * f;
}

void dfs( int u, int p, int w )
{
    dep[u] = dep[p] + 1;
    up[u][0] = p;
    dist[u] = dist[p] + w;
    edgew[u] = w;

    for( int i = 1; i < maxlg; ++ i )
        up[u][i] = up[up[u][i - 1]][i - 1];

    for( auto &[v, w] : adj[u] )
        if( v != p ) dfs( v, u, w );
}

int get_lca( int u, int v )
{
    if( dep[u] < dep[v] ) swap( u, v );
    int diff = dep[u] - dep[v];
    for( int i = 0; i < maxlg; ++ i )
        if( ( diff >> i ) & 1 ) u = up[u][i];
    if( u == v ) return u;
    for( int i = maxlg - 1; i >= 0; -- i )
        if( up[u][i] != up[v][i] )
            u = up[u][i], v = up[v][i];
    return up[u][0];
}

void dfs_sum( int u, int p, int cnt )
{
    sum[u] = diff[u];
    for( auto &[v, w] : adj[u] )
        if( v != p ) dfs_sum( v, u, cnt ), sum[u] += sum[v];
    if( sum[u] == cnt ) max_edge = max( max_edge, edgew[u] );
}

bool check( int mid )
{
    int cnt = 0;
    for( int i = 1; i <= n; ++ i ) diff[i] = 0;

    for( int i = 1; i <= m; ++ i )
    {
        if( p[i].len <= mid ) continue;
        cnt ++;
        diff[p[i].u] ++, diff[p[i].v] ++;
        diff[p[i].lca] -= 2;
    }
    if( cnt == 0 ) return 1;

    max_edge = 0;
    dfs_sum( 1, 0, cnt );
    
    return max_len - max_edge <= mid;
}

int main( )
{
    n = read( ), m = read( );
    for( int i = 1; i <= n - 1; ++ i )
    {
        int u, v, w;
        u = read( ), v = read( ), w = read( );
        adj[u].push_back({ v, w });
        adj[v].push_back({ u, w });
        max_weight = max( max_weight, w );
    }

    dfs( 1, 0, 0 );

    for( int i = 1; i <= m; ++ i )
    {
        p[i].u = read( ), p[i].v = read( );
        p[i].lca = get_lca( p[i].u, p[i].v );
        p[i].len = dist[p[i].u] + dist[p[i].v] - 2 * dist[p[i].lca];
        max_len = max( max_len, p[i].len );
    }

    int l = max( 0, max_len - max_weight ), r = max_len, ans = max_len;
    while( l <= r )
    {
        int mid = ( l + r ) >> 1;
        if( check( mid ) ) ans = mid, r = mid - 1;
        else l = mid + 1;
    }
    cout << ans << '\n';
    return 0;
}
```

{% endfold %}

## 4. 复盘

- **复杂度分析**：$O( M \log N + N \log (\text{max\_dist}) )$。
    
- **碎碎念**：这题还有不少常数上的坑，比如要用快读，比如要优化二分的区间，特别是下边界，不然就会 TLE，很可恶。

- **关联知识点**：[[LCA 体系]] | [[树上差分]] | [[二分体系]]