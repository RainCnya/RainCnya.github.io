---
title: '[Leaf] [P1967] 货车运输'
tags:
  - 图论/生成树
  - 树论/LCA
  - 难度/P3
categories:
  - 220_Library
  - 20_图论
  - 22_树论专题
abbrlink: 7fb577ad
date: 2025-12-18 00:00:00
updated: 2026-02-05 21:20:02
---
# [P1967 [NOIP 2013 提高组] 货车运输 - 洛谷](https://www.luogu.com.cn/problem/P1967)

## 1. 题面梗概

**中译中**: 给一张带权无向图。多次询问两点 $(x, y)$ 之间所有路径中，**最小边权的最大值**是多少。如果两点不连通，输出 $-1$。

## 2. 逻辑推导

这其实是典型的瓶颈路问题，我们需要找一条路，让它在最窄的地方尽可能宽。但如果直接在原图上炮搜索，多次独立查询复杂度绝对会爆炸。

### 2.1 生成树

在一个带权无向图上，两点间的“最小边权最大”的路径，一定位于该图的最大生成树上。（同理，两点间“最大边权最小”的路径，一定位于该图的最小生成树上）。

接着我们反转 $Kruskal$ 贪心，优先选择最大边权的边连接连通块，这样就把原本的图转化为了一个最大生成森林。

### 2.2 LCA

现在我们把问题转化为了，如何求树上两点路径间的边权最小值。

这里我们可以采用 LCA 倍增法，同时维护 祖先 和 路上最小边权。

### 2.3 结论

这是个变种最小生成树问题——最大生成树，同时小心图可能不联通。

## 3. 代码实现

{% fold info @AcCode %}

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int maxn = 1e4 + 50;
const int maxm = 5e4 + 50;
const int maxlg = 20;
const int inf = 0x3f3f3f3f;

struct Edge { int u, v, w; } edges[maxm];
struct Node { int v, w; };
vector< Node > adj[maxn];
int fa[maxn], dep[maxn];
int up[maxn][maxlg];
int min_w[maxn][maxlg];
bool vis[maxn];
int n, m, q;

bool cmp( const Edge &lhs, const Edge &rhs ) { return lhs.w > rhs.w; }

int find( int x ) { return fa[x] == x ? x : fa[x] = find( fa[x] ); }

void dfs( int u, int p, int w )
{
    vis[u] = 1;
    dep[u] = dep[p] + 1;
    up[u][0] = p;
    min_w[u][0] = w;

    for( int i = 1; i < maxlg; ++ i )
    {
        up[u][i] = up[up[u][i - 1]][i - 1];
        min_w[u][i] = min( min_w[u][i - 1], min_w[up[u][i - 1]][i - 1] );
    }
    
    for( auto [v, w] : adj[u] )
    {
        if( v != p ) dfs( v, u, w );
    }
}

int query( int u, int v )
{
    if( dep[u] < dep[v] ) swap( u, v );
    int diff = dep[u] - dep[v];
    int res = inf;

    for( int i = 0; i < maxlg; ++ i )
    {
        if( ( diff >> i ) & 1 )
        {
            res = min( res, min_w[u][i] );
            u = up[u][i];
        }
    }

    if( u == v ) return res;
    
    for( int i = maxlg - 1; i >= 0; -- i )
    {
        if( up[u][i] != up[v][i] )
        {
            res = min( res, min_w[u][i] );
            res = min( res, min_w[v][i] );
            u = up[u][i];
            v = up[v][i];
        }
    }

    res = min( res, min_w[u][0] );
    res = min( res, min_w[v][0] );
    return res;
}


void solve( )
{
    cin >> n >> m;
    for( int i = 1; i <= m; ++ i )
    {
        int u, v, w;
        cin >> u >> v >> w;
        edges[i] = { u, v, w };
    }
    sort( edges + 1, edges + m + 1, cmp );

    for( int i = 1; i <= n; ++ i ) fa[i] = i;
    
    for( int i = 1; i <= m; ++ i )
    {
        auto [u, v, w] = edges[i];
        int ru = find( u ), rv = find( v );
        if( ru != rv )
        {
            fa[ru] = rv;
            adj[ru].push_back( { rv, w } );
            adj[rv].push_back( { ru, w } );
        }
    }

    memset( min_w, 0x3f, sizeof (min_w) );
    for( int i = 1; i <= n; ++ i )
    {
        if( !vis[i] ) dfs( i, 0, 0 );
    }
    
    cin >> q;
    while( q -- )
    {
        int u, v;
        cin >> u >> v;
        if( find( u ) != find( v ) ) cout << -1 << '\n';
        else cout << query( u, v ) << '\n';
    }
}

int main( )
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    solve( );
    return 0;
}
```

{% endfold %}

## 4. 复盘

- **复杂度分析**：建树 $O(M \log M)$，预处理 $O(N \log N)$，查询 $O(Q \log N)$。
    
- **认知补丁**：**瓶颈路性质**：最大生成树上的路径即为“最小权值最大”的路径；最小生成树上的路径即为“最大权值最小”的路径。
        
- **碎碎念**：这题是生成树与树论倍增的结合。`min_w` 的更新逻辑和 LCA 跳转的状态逻辑同步，因此采用这种树上 ST 表。
    
- **关联笔记**：[[生成树体系]] | [[LCA 体系]]