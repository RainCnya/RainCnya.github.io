---
title: 动态规划：状态公理与决策本质 (DP Core Synthesis)
tags:
  - 指南/方法论
  - 指南/DP
categories:
  - 01_Patchouli
  - 03_动态规划
  - 00_核心体系
abbrlink: 1c960464
date: 2025-12-16 22:05:00
---
# 动态规划综述
## 1. 生态位

- **定义**: 动态规划是将复杂的多阶段决策过程坍缩为有序状态流转的方法论。
    
- **解决痛点**: 解决了指数级搜索空间（Brute Force）中的**冗余计算**问题。
    

## 2. 逻辑支点

- **核心不变量**:
    
    1. **最优子结构**: 全局最优决策序列的每一个子序列也必须是局部的最优决策。
        
    2. **重叠子问题**: 不同的决策路径可以交汇于同一个物理状态。
        
    3. **无后效性 (Non-aftereffect)**: 状态是历史的完整浓缩。一旦进入 $S$，后续演化仅取决于 $S$，与抵达 $S$ 的路径无关。
        
- **渗透点 (Penetration)**:
    
    > DP 的本质是 **DAG 上的最短路/最长路**。 所谓的“状态”是图中的节点，“转移”是带权的边，“目标”是路径的测度。如果状态图产生了环，DP 则退化为最短路算法（如 SPFA/Dijkstra）。
    

## 3. 实战部署

> **Standard**: Airy Strict v3.2

### 3.1 记忆化搜索 (Top-Down)

适用于状态空间稀疏、转移逻辑复杂的场景。

{% fold info @Code: Memoization Template %}

```cpp
// 记忆化搜索：本质是带缓存的 DFS
int memo[ maxn ];

int dfs( int u )
{
    // 1. 命中缓存直接返回
    if( memo[ u ] != -1 ) 
    {
        return memo[ u ];
    }

    int res = 0;
    // 2. 遍历所有后继状态 (边)
    for( int v : adj[ u ] )
    {
        res = max( res, dfs( v ) + w[ u ][ v ] );
    }

    return memo[ u ] = res;
}
```

{% endfold %}

### 3.2 递推范式 (Bottom-Up)

适用于状态稠密、需要滚动数组优化空间或进行维度打击（单调队列/斜率优化）的场景。

{% fold info @Code: Tabulation Template %}

```cpp
// 递推：遵循拓扑序进行状态演化
void solve( )
{
    memset( f, 0, sizeof( f ) );
    f[ 0 ] = start_val;

    for( int i = 1; i <= n; ++ i )
    {
        for( int j = 0; j < i; ++ j )
        {
            // 决策转移
            if( check( j, i ) )
            {
                f[ i ] = max( f[ i ], f[ j ] + cost( j, i ) );
            }
        }
    }
}
```

{% endfold %}

## 4. 知识粘附

- **变体模型**:
    
    - [分层图最短路](分层图最短路.md): 典型的“状态升维”以消除后效性的范式。
        
    - [最短路图](最短路图.md): 将一般图 DP 化的核心中介。
        
- **母题索引**:
    
    - [P1280 尼克的任务 (Seq_Reverse_DP)](P1280%20尼克的任务%20(Seq_Reverse_DP).md) —— 逆序决策消除未来影响的典范。