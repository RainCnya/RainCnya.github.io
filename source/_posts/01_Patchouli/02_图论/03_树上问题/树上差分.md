---
title: 树上差分 (Tree_Difference)
tags:
  - 逆运算/树上差分
  - 树论/LCA
categories:
  - 01_Patchouli
  - 02_图论
  - 03_树上问题
abbrlink: 4f9d9d38
date: 2025-12-16 14:20:00
updated: 2025-12-24 19:07:54
---
# 树上差分

## 1. 生态位

- **定义**: 差分是前缀和的逆运算，其本质是“贡献的局部标记”。在树上，它通过在路径端点施加抵消性的增量，将路径范围的修改坍缩为 $O(1)$ 的端点打标。
    
- **解决痛点**: 离线批量处理海量的树上路径修改任务（如：路径加 $K$、路径覆盖统计），最后通过一次自底向上的聚合（DFS 汇总）还原全局信息。
    

## 2. 逻辑支点

- **影响抵消机制**:
    
    - **点差分**: `diff[u]++`, `diff[v]++`, `diff[LCA]--`, `diff[fa[LCA]]--`。旨在统计节点被覆盖的频次。
        
    - **边差分**: `diff[u]++`, `diff[v]++`, `diff[LCA]-=2`。旨在统计边被覆盖的频次（权值通常挂在深节点上）。
        
- **渗透点**:
    
    - 点差分的 `fa[LCA]` 减法是为了彻底切断路径贡献向上传递的“溢出”，确保贡献仅局限在 $u \to v$ 的链上。
        
    - 差分还原的本质是子树和。
        

## 3. 实战部署

{% fold info @Code: Tree Difference & DFS Recovery %}

```cpp
// 1. 端点标记 (以点差分为例)
void add_path( int u, int v )
{
    int rt = get_lca( u, v );
    ++ diff[ u ];
    ++ diff[ v ];
    -- diff[ rt ];
    -- diff[ fa[ rt ][ 0 ] ];
}

// 2. 自底向上汇总还原
void dfs_sum( int u, int father )
{
    for( int v : adj[ u ] )
    {
        if( v != father )
        {
            dfs_sum( v, u );
            diff[ u ] += diff[ v ];
        }
    }
    // 此时 diff[u] 即为该点的最终权值/覆盖次数
}
```

{% endfold %}

## 4. 知识粘附

- **变体应用**:
    
    - **序列修正**: 处理路径拼接时的转折点重复计算（如 P3258）。
        
    - **桶计数结合**: 利用 DFS 序进出栈的桶差值统计动态属性（如 P1600）。
        
- **母题索引**:
    
    - [P3128 Max Flow P (LCA_Point_Difference)](P3128%20Max%20Flow%20P%20(LCA_Point_Difference).md)
        
    - [P3258 松鼠的新家 (LCA_Point_Difference_Unique)](P3258%20松鼠的新家%20(LCA_Point_Difference_Unique).md)
        
    - [P3406 海底高铁 (Chain_Difference)](P3406%20海底高铁%20(Chain_Difference).md)]
        
    - [P2680 运输计划 (LCA_Difference_BinarySearch)](P2680%20运输计划%20(LCA_Difference_BinarySearch).md)
        
    - [P1600 天天爱跑步 (LCA_Bucket_Difference)](P1600%20天天爱跑步%20(LCA_Bucket_Difference).md)