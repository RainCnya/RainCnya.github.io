---
title: Project Selene | 折桂计划
tags: Meta/Selene
categories:
  - 290_Essays
archive: true
abbrlink: Selene
date: 2026-01-16 00:00:00
---
## 内生秩序

> **"盛开本身，就是生长积累后的必然结果。"**

如果你看到了这个页面，说明你顺着逻辑的线索，找到了这里。 

这里没有捷径，只有一套枯燥的、需要长时间投入的**系统重构方案**。

### 0. 灵感

这套逻辑并非凭空产生，它源于国内最顶尖选手的实战总结。 

在开始一切之前，我强烈建议你花 1 个小时，完整阅读/观看这份逻辑来源。

- **核心理论**：[怎么搞 OI？- 杨宇辰 (NOI 2021 金牌)](https://www.bilibili.com/video/BV1xSYxzDEPg)
    
- **理由**：这是“焚诀”的理论原型。我的演讲是预告片，这才是正片。

### 1. 焚诀

基于上述理论，我将其重构为适合我们的执行策略。

#### > 阶段一：渗透

- **原则**：自顶向下，先宏观后微观。
	
- **领域**：对于框架性渗透，你需要回答三问：

	1. 这个领域有哪些知识？
		
	2. 它们之间的依赖关系是什么？
		
	3. 应该按什么顺序学？
    
- **知识点**：在学算法前，你必须回答这五问：

	1. **识别**：它是什么？
		
    2. **地位**：它在知识图谱的哪个节点？是根基还是枝叶？
        
    3. **用途**：它解决什么问题？有什么限制？有什么优势？
        
    4. **原理**：核心思想是什么？（如：贪心、松弛、分治）
		
	5. **代码**：最后才是具体实现的代码细节。

#### > 阶段二：题解加速

- **原则**：抛弃伪自尊，拥抱逻辑。
    
- **阈值**：卡题 > 3小时 $\rightarrow$ **系统死锁** $\rightarrow$ **立即看题解**。
    
- **闭环**：看懂 $\neq$ 学会。必须关掉题解，**独立复现代码**。

#### > 阶段三：多线程

- **策略**：维护三个题目池 ( Pool A/B/C )，拒绝大脑空转。

	- A：待筛选的题源 / B：看懂逻辑待复盘 / C：写完复盘待代码
    
- **狂战士**：在手感极佳时，**无视难度越级学习**，强行撑大思维带宽。
    

### 2. 寒假指南

这是 Project Selene 的起跑线。目标是跑通所有基础模型，建立稳定的代码带宽。

#### 第一阶段：代码带宽与基础战术

- **[L2-00] 预备知识**：位运算、时间/空间复杂度分析意识。
    
- **[L2-01] 基础战术**：快速排序思想、二分查找、二分答案（单调性模型）。
    
- **[L2-11] 常用工具**：STL 容器（`vector`, `map`, `set`, `priority_queue`）的熟练运用。
    
#### 第二阶段：线性思维与搜索

- **[L2-02] 降维技巧**：双指针、前缀和、差分、离散化。
    
- **[L2-03] 逻辑搜索**：DFS（递归回溯）、BFS（队列层级）。
    
- **[L2-12] 基础结构**：并查集（路径压缩）、树状数组（区间和）。

#### 第三阶段：图论基础与空间思维

- **[L2-20] 存图协议**：邻接表、链式前向前（静态数组模拟）。
    
- **[L2-21] 最短路**：Dijkstra 堆优化、SPFA 判负环。
    
- **[L2-22] 树论初步**：最近公共祖先 (LCA) 倍增实现、ST 表 (RMQ)。
    
#### 第四阶段：动态规划与数学基础

- **[L2-30] 基础 DP**：0/1 背包、完全背包、线性 DP (LIS, LCS)。
    
- **[L2-40] 基础数学**：快速幂、线性筛素数、乘法逆元（费马小定理）、组合数取模。

- 如果你觉得简单了，随时找我加练！

### 3. 渗透笔记

为了防止“眼高手低”，每一道典型题/每一个算法，都必须产出一份 **渗透学习笔记**。 

**要求**：能用自然语言，把逻辑讲给一个不懂的人听懂。


```markdown
[样例] 图论 - Kruskal最小生成树

- 识别：最小生成树（MST）是在保持连通性的同时，找出最优成本路径。
  
- 地位：解决“连通性成本最低”类问题的基础算法。
  
- 适用条件：稀疏图（E ≈ V），对比 `Prim` 算法写起来更简单。

- 核心原理：贪心 + 并查集去环。
  
- 具体实现：把所有的边按权值从小到大排序，依此处理每一条边：如果这条边连接的两个点 **还不在同一个集合** 里（即不会形成环），就选它；否则就扔掉。

- 前置知识：并查集判环。
  
- 代码示例(...)

- 复盘(坑):
	1. 排序写反 `cmp` 函数。
	2. 并查集没初始化。
	3. 图不连通 -- 无解。
	   
- 总结：相比起来，`kruskal`，只需要一次排序就行，非常无脑，总之把 `prim` 优化掉了。
```


### 4. 链接

**折桂计划 (Project Selene)** 并不是什么高大上的组织。

说白了，它是一个以我和我的队友为核心的**算法学习实验小组**。

在这个寒假，我会提供**基础算法学习路线**，我会设定**每周的学习任务**，我会陪着大家一起打卡、复盘、重构、打模拟赛。

**但我必须坦诚，这真的会很累。** 你需要在寒假投入很多时间，你需要强迫自己写出那种“讲给人听”的 **渗透学习笔记**，你可能需要面对看不懂，学不会的问题。

**我会帮你完成重构，只要你能跟上。所以，你愿意参加这个实验吗？或者说，你愿意信任我吗？**

如果你决定了参加这场“信任实验”，请：

1. **自学**：先利用 [OI Wiki](https://oi-wiki.org/) 或 [互联网博客] 尝试写一篇 关于DFS 的渗透学习笔记。
    
2. **连接**：带着这篇笔记，通过 **Email** 联系我: [raincnya@gmail.com]。 

**我们不等待风，我们自己定义风向。愿你的旅途星光璀璨。**
