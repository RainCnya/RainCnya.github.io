---
title: 重链剖分 (Tree_HLD_System)
tags:
  - 图论/树论/树链剖分
  - 数据结构/线段树
  - 图论/树论/LCA
categories:
  - 211_Patchouli
  - 02_图论
  - 03_树上问题
abbrlink: 5e08b96b
date: 2025-12-16 14:10:00
updated: 2025-12-24 19:07:49
---
# 重链剖分

## 1. 生态位

- **定义**: 重链剖分（HLD）是通过轻重边划分将树结构线性化的一种范式。它将树上的路径查询与修改任务，投影到由 $O(\log N)$ 段连续区间组成的序列上。其本质是“树向线段树的逻辑映射”，实现了非线性结构的对数级降维维护。
    
- **解决痛点**: 解决了树上动态路径修改、动态路径求和以及 LCA 极速查询问题。
    

## 2. 逻辑支点

- **重边不变量**: 对于每个节点，选择其子树规模（size）最大的子节点作为重儿子，其余为轻儿子。由此构成的“重链”具有以下性质：从根到任意点的路径，经过的轻边数量不超过 $\log N$ 条。
    
- **DFS 序重排**: 在进行 DFS 遍历时，优先访问重儿子。这确保了同一条重链上的节点在 DFS 序（dfn）中是连续分布的。
    
- **渗透点**: 重链剖分是树的“脊柱抽取”。它识别出树中密度最高的主干，将其固化为序列，而将轻儿子视为挂载在主干上的零散构件。
    

## 3. 实战部署

### 3.1 核心 2-DFS 模板

{% fold info @Code: HLD 2-DFS %}

```cpp
int fa[ maxn ], dep[ maxn ], sz[ maxn ], son[ maxn ];
int top[ maxn ], dfn[ maxn ], rnk[ maxn ], timer;

// 第一遍 DFS：确定父、深、子树大小、重儿子
void dfs1( int u, int f, int d )
{
    fa[ u ] = f;
    dep[ u ] = d;
    sz[ u ] = 1;
    son[ u ] = -1;
    for( int v : adj[ u ] )
    {
        if( v == f ) continue;
        dfs1( v, u, d + 1 );
        sz[ u ] += sz[ v ];
        if( son[ u ] == -1 || sz[ v ] > sz[ son[ u ] ] )
        {
            son[ u ] = v;
        }
    }
}

// 第二遍 DFS：确定重链顶点、DFS 序
void dfs2( int u, int t )
{
    top[ u ] = t;
    dfn[ u ] = ++ timer;
    rnk[ timer ] = u;
    if( son[ u ] == -1 ) return;
    
    // 优先处理重儿子，确保护序连续
    dfs2( son[ u ], t );
    
    for( int v : adj[ u ] )
    {
        if( v != fa[ u ] && v != son[ u ] )
        {
            dfs2( v, v ); // 轻儿子开启新链
        }
    }
}
```

{% endfold %}

## 4. 知识粘附

- **变体模型**:
    
    - **长链剖分**: 深度最深者为重儿子，用于优化深度相关的 DP。
        
    - **LCT (Link-Cut Tree)**: 动态的剖分维护。
        
- **母题索引**:
    
    - [P3384 【模板】重链剖分](https://www.luogu.com.cn/problem/P3384 "null") —— 基础路径修改与查询。