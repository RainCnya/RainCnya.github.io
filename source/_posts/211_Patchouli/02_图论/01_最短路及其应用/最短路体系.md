---
title: 最短路体系 (SSSP System)
tags:
  - 图论/最短路
  - 图论/最短路/最短路图
categories:
  - 211_Patchouli
  - 02_图论
  - 01_最短路及其应用
abbrlink: a535be86
date: 2025-12-12 01:33:58
updated: 2025-12-24 19:05:16
---
# 最短路体系 (SSSP System)

## 1. 生态位

- **定义**: 在加权图中，寻找从源点到目标点总权值最小的路径。
    
- **解决痛点**:
    
    - **物理映射**: 路径导航、流量分配。
        
    - **逻辑降维**: 将复杂的代数约束（差分约束）或状态转换（同余最短路）转化为图论路径搜索。

- **核心**：松弛操作（Relaxation）。
## 2. 逻辑支点

- **核心不变量**: 三角不等式 $dist[v] \le dist[u] + w(u, v)$。算法的本质是不断寻找并消除违反此不等式的边。
    
- **状态转移/数学推导**: 对于分层图模型，状态升维为：
    
    $$dist[u][k] = \min(dist[u][k], dist[v][k] + w, dist[v][k-1] + 0)$$
    
    其中 $k$ 代表消耗的“特殊权力”次数。
    
- **渗透点 (Penetration)**:
    
    - **Dijkstra** 的本质是排队。每个点在被选出的一刻，其在该约束环境下的最优性即确立。
        
    - **SPFA** 的本质是纠错。当一个点的代价被优化，其所有邻居都获得了被重新审视的机会。
        
    - **Floyd** 的本质是插点。它通过动态解锁中转点 $k$，逐步完善全图的通达代价。
        

## 3. 实战部署

### 3.1 Dijkstra (标准模板：优先队列)

适用于**非负权**单源最短路，是大多数场景下的标准选型。

{% fold info @Code: Dijkstra Standard %}

```cpp
void dijkstra( int st )
{
    for( int i = 1; i <= n; ++ i )
    {
        dist[ i ] = inf;
        vis[ i ] = 0;
    }
    dist[ st ] = 0;
    priority_queue< PII, vector< PII >, greater< PII > > pq;
    pq.push( { 0, st } );

    while( !pq.empty( ) )
    {
        auto [ d, u ] = pq.top( );
        pq.pop( );

        if( vis[ u ] ) continue;
        vis[ u ] = 1;

        for( auto &e : adj[ u ] )
        {
            if( dist[ u ] + e.w < dist[ e.v ] )
            {
                dist[ e.v ] = dist[ u ] + e.w;
                pq.push( { dist[ e.v ], e.v } );
            }
        }
    }
}
```

{% endfold %}

### 3.2 SPFA (队列优化：负权与负环)

适用于**含负权边**或需要判定**负环**（差分约束核心）的场景。

{% fold info @Code: SPFA with Negative Cycle Detection %}

```cpp
bool spfa( int st )
{
    for( int i = 1; i <= n; ++ i )
    {
        dist[ i ] = inf;
        vis[ i ] = 0;
        cnt[ i ] = 0;
    }
    dist[ st ] = 0;
    queue< int > q;
    q.push( st );
    vis[ st ] = 1;

    while( !q.empty( ) )
    {
        int u = q.front( );
        q.pop( );
        vis[ u ] = 0;

        for( auto &e : adj[ u ] )
        {
            if( dist[ u ] + e.w < dist[ e.v ] )
            {
                dist[ e.v ] = dist[ u ] + e.w;
                cnt[ e.v ] = cnt[ u ] + 1;
                if( cnt[ e.v ] >= n ) return true; // 发现负环

                if( !vis[ e.v ] )
                {
                    q.push( e.v );
                    vis[ e.v ] = 1;
                }
            }
        }
    }
    return false;
}
```

{% endfold %}

### 3.3 Floyd (多源汇：阶段插点)

适用于**多源最短路**、**传递闭包**或**最小环**判定。

{% fold info @Code: Floyd Standard & Min-Cycle Variant %}

```cpp
// 标准 Floyd: k 必须在最外层
for( int k = 1; k <= n; ++ k )
{
    // 变体: 寻找最小环 (在用 k 更新 dist 前)
    /*
    for( int i = 1; i < k; ++ i )
        for( int j = i + 1; j < k; ++ j )
            ans = min( ans, dist[ i ][ j ] + w[ i ][ k ] + w[ k ][ j ] );
    */

    for( int i = 1; i <= n; ++ i )
    {
        for( int j = 1; j <= n; ++ j )
        {
            if( dist[ i ][ k ] + dist[ k ][ j ] < dist[ i ][ j ] )
            {
                dist[ i ][ j ] = dist[ i ][ k ] + dist[ k ][ j ];
            }
        }
    }
}
```

{% endfold %}

## 4. 知识粘附 (Adhesion)

- **变体模型**:
    
    - [分层图最短路](../分层图最短路.md): 处理 $K$ 次特殊操作的机会。

    - [最短路图](../最短路图.md): 提取所有属于最短路的边，转化为 DAG 进行计数或 DP。
          
    - [同余最短路](../同余最短路.md): 将数值范围映射为余数类节点，压缩解空间。
        
- **母题索引**:
    
    - [CF1076D Edge Deletion (Dijkstra_SPT)](CF1076D%20Edge%20Deletion%20(Dijkstra_SPT).md)
        
    - [P1993 小K的农场 (Difference_Constraints)](P1993%20小K的农场%20(Difference_Constraints).md)
        
    - [P2371 墨墨的等式 (Modulo_Shortest_Path)](P2371%20墨墨的等式%20(Modulo_Shortest_Path).md)
        
    - [P1119 灾后重建 (Floyd_Dynamic_Time)](P1119%20灾后重建%20(Floyd_Dynamic_Time).md)
        
    - [P6175 无向图的最小环 (Floyd_Min_Cycle)](P6175%20无向图的最小环%20(Floyd_Min_Cycle).md)