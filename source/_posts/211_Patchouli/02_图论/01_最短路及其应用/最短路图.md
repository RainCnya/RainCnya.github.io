---
title: 最短路图 (Shortest Path DAG)
tags:
  - 图论/最短路
  - 图论/DAG
categories:
  - 211_Patchouli
  - 02_图论
  - 01_最短路及其应用
abbrlink: 5a7613f
updated: 2025-12-24 19:05:23
---

# 最短路图 (Shortest Path DAG)

## 1. 生态位

- **定义**: 通过剥离所有非最优路径边，将复杂图精炼提取为纯净的有向无环图（DAG），从而释放拓扑计数与动态规划的潜力。它仅包含满足 $dist(S, u) + w(u, v) + dist(v, T) = dist(S, T)$ 约束的边。
    
- **解决痛点**: 解决了最短路方案数统计以及最优路径交集分析等问题，将路径搜索转化为 DAG 上的递推。
    

## 2. 逻辑支点

- **核心不变量**: 边权的松弛守恒。若边 $(u, v)$ 属于最短路图，则它必定完美满足 $dist[v] = dist[u] + w$。
    
- **判定准则**:
    
    $$d_S[u] + w(u, v) + d_T[v] = d_S[T]$$
- **渗透点 (Penetration)**: 最短路图是原图的“最优骨架”。在这个骨架上，所有移动都必然严格靠近终点，不存在任何无效的回头路或环路。
    

## 3. 实战部署

{% fold info @Code: Building Shortest Path DAG %}

```cpp
// 1. 跑两遍 Dijkstra: 起点 S -> dS[], 终点 T -> dT[]
// 2. 遍历所有边提取 DAG 边集
void extract_dag( )
{
    for( int u = 1; u <= n; ++ u )
    {
        for( auto &e : adj[ u ] )
        {
            int v = e.v, w = e.w;
            // 判定边 (u, v) 是否处于 S 到 T 的最短路上
            if( dS[ u ] + w + dT[ v ] == dS[ T ] )
            {
                dag[ u ].push_back( { v, w } );
                in_degree[ v ] ++; 
            }
        }
    }
}
```

{% endfold %}

## 4. 知识粘附

- **变体模型**:
    
    - **最短路计数**: 在 DAG 上运行简单的加法原理递推。
        
    - **公共最短路**: 对不同点对分别建图并求边集交集。
        
- **母题索引**:
    
    - [P2149 Elaxia 的路线 (Dijkstra_Common_Path)](P2149%20Elaxia%20的路线%20(Dijkstra_Common_Path).md) —— 最短路图交集与 DAG 最长链。
        
    - [P1144 最短路计数 (Shortest_Path_Counting)](P1144%20最短路计数%20(Shortest_Path_Counting).md) —— 最短路图上的拓扑递推。
