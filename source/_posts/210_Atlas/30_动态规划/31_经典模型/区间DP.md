---
title: '[Note] 区间DP'
tags:
  - DP/区间
  - 算法/环形处理
  - 难度/P3
categories:
  - 210_Atlas
  - 30_动态规划
  - 31_经典模型
abbrlink: a75f3b7c
date: 2026-02-03 15:29:45
---
# [L4] 区间DP

## 1. 生态位

- **识别**:
    
    1. **递归子结构**: 题目涉及**括号匹配**、**二叉树遍历还原**等具有递归子结构的问题。
        
    2. **合并/消除**: 只有**相邻**元素才能互动（合并、消除、覆盖）。
        
    3. **区间的端点**: 操作往往发生在区间的边缘（如回文串、进队出队）。

- **地位**：动态规划中的区间处理工具。建立了以**区间长度**为拓扑轴，同时也是 **树形DP** 的逆过程。
        
- **用途**：**代价最优化**: 石子合并、矩阵链乘。**结构计数**: 合法括号序列计数、回文串构造。

## 2. 逻辑支点

### 2.1 核心原理

线性 DP 的“时间”是下标 $i$，而区间 DP 的“时间”是**长度** $len$。

- **物理意义**: 任何大的区间 $[l, r]$ 都是由更小的子区间递推而来的。
    
- **拓扑序**: 必须先计算 $len=1$ 的状态，再计算 $len=2, \dots, N$。

### 2.2 状态转移

区间DP 的状态转移本质上都是在寻找，这一段区间最后一次操作发生在哪个位置。

#### A. 分割点 —— 寻找支点

适用于 **合并类** 问题。

- **逻辑**: 区间 $[l, r]$ 是由 $[l, k]$ 和 $[k+1, r]$ 在最后一步合并而成的。
    
- **方程**: $f[l][r] = \max (f[l][k] + f[k+1][r] + Cost)$。
    
- **典型**: 石子合并、加分二叉树（$k$ 即根节点）。

#### B. 端点 —— 寻找边界

适用于 **回文/覆盖类** 问题。

- **逻辑**: 区间 $[l, r]$ 的性质由端点 $l$ 和 $r$ 的关系决定。如果 $S[l] == S[r]$，则可能无需额外代价即可从内部扩张。
    
- **方程**: $f[l][r] = \min (f[l+1][r] + Cost_L, f[l][r-1] + Cost_R)$。
    
- **典型**: 回文串构造、涂色问题（$l, r$ 同色时可省一次操作）。

#### C. 反向思考 —— 寻找终态

适用于 **进出栈/消除类** 问题。

- **逻辑**: 当正向思考 **谁先被消除** 很困难时，反向思考 **谁留到了最后**。
    
- **典型**: [[P3205 合唱队]] | [[P5851 Greedy Pie Eaters P]]

### 2.3 断环成链

对于环形问题（如项链、环形石子），不需要复杂的取模运算。

- **操作**: 将数组复制一份接在末尾 $A[1\dots N] \to A[1 \dots 2N]$。
    
- **获取答案**: 扫描所有长度为 $N$ 的子区间 $[i, i+N-1]$ 取最值。

## 3. 实战部署

### 3.1 标准迭代

适用于大多数 $O(N^3)$ 的合并问题。

{% fold info @区间DP: 标准模板 %}

```cpp
// 核心：三层循环。
// Layer 1: 长度 (时间轴)
for( int len = 2; len <= n; ++ len )
{
    // Layer 2: 左端点 (空间位置)
    for( int l = 1; l + len - 1 <= n; ++ l )
    {
        int r = l + len - 1;
        // Layer 3: 分割点/决策 (动作)
        // 场景 A: 枚举分割点 k
        for( int k = l; k < r; ++ k )
        {
            f[l][r] = min( f[l][r], f[l][k] + f[k+1][r] + calc(l,r) );
        }
        // 场景 B: 端点决策 (回文/涂色)
        if( s[l] == s[r] ) f[l][r] = min( f[l][r], f[l+1][r-1] );
        else f[l][r] = min( f[l][r], min(f[l+1][r], f[l][r-1]) + 1 );
    }
}
```

{% endfold %}

### 3.2 记忆化搜索

适用于 **状态稀疏** 或 **逻辑复杂**（如括号匹配、树结构解析）的问题。

{% fold info @区间DP: 递归模板 %}

```cpp
// 针对 CF149D 括号染色，状态带额外限制
long long solve( int l, int r, int color_l, int color_r )
{
    if( l >= r ) return 0; // 边界
    if( memo[l][r][color_l][color_r] != -1 ) return memo[l][r][color_l][color_r];

    long long ans = 0;
    // 逻辑分叉：是嵌套 (A) 还是拼接 AB
    if( match[l] == r ) {
        // 嵌套处理：递归内层 [l+1, r-1]
    } else {
        int k = match[l];
        // 拼接处理：裂解为 [l, k] 和 [k+1, r]
    }
    return memo[l][r][color_l][color_r] = ans;
}
```

{% endfold %}

## 4. 知识关联

- **4.1 基础合并与环形处理**
    
    - [[P1880 石子合并]] —— **区间DP母题**。确立了从小区间向大区间转移的 $O(N^3)$ 范式及断环成链技巧。
        
    - [[P1063 能量项链]] —— **矩阵链乘变体**。特征值由头尾决定 ($head \times tail \times tail_{next}$)，而非简单的重量求和。
        
- **4.2 结构还原与递归**
    
    - [[P1040 加分二叉树]] —— **树形还原**。中序遍历区间对应的子树结构，枚举 $k$ 即枚举树根。
        
    - [[CF149D Coloring Brackets]] —— **括号递归**。利用括号序列的嵌套/拼接特性，进行记忆化搜索转移。
        
- **4.3 回文与覆盖**
    
    - [[P2890 Cheapest Palindrome G]] —— **对称性**。回文的本质是对称，增字与删字在消除不对称性上等价。
        
    - [[P4170 涂色]] —— **端点贪心**。当 $s[l] == s[r]$ 时，利用一次涂色覆盖两端，实现 $O(1)$ 转移。
        
- **4.4 逆向思维**
    
    - [[P3205 合唱队]] —— **逆向思维**。不思考谁先入队，而思考“最后一个人是谁”，从而锁定区间边界。
        
    - [[P5851 Greedy Pie Eaters P]] —— **逆向思维**。枚举“最后被吃掉的饼”，将区间划分为独立的子问题，需辅助数组预处理。
        
- **关联笔记**:
    
    - [[树形DP]]: 区间 DP 的递归结构往往对应着树的 DFS 序，二者经常交织。
        
    - [[四边形不等式]]: 针对 $f[l][r] = \min(f[l][k] + f[k+1][r]) + w[l][r]$ 这类 $O(N^3)$ 转移的 $O(N^2)$ 优化工具。
        
    - [[回文串]]: Manacher 与 PAM 是处理回文问题的另一条（非 DP）路径。
        