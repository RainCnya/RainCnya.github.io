---
title: '[Note] SOSDP'
tags:
  - 算法/前缀差分
  - DP/状压
  - 难度/P3
categories:
  - 210_Atlas
  - 30_动态规划
  - 32_状态压缩
abbrlink: 5db37e5a
date: 2026-01-04 00:00:00
---
# [L4] SOSDP

## 1. 生态位

- **识别**:
    
    1. 给定集合函数 $A$，求其所有子集的权值和，即 $F[mask] = \sum_{sub \subseteq mask} A[sub]$。
        
    2. 这种问题通常出现在下标是二进制掩码（Mask）的情况下。
        
- **地位**: 降维技巧的高级应用。是解决子集问题的降维技巧。
    
- **用途**: 将复杂度从暴力枚举子集的 $O(3^n)$ 杀到逐维处理的 $O(n \cdot 2^n)$。

## 2. 逻辑支点

- **核心原理：逐维折叠**:
    
    - **物理直觉**：把 $n$ 位的二进制看作一个 $n$ 维空间。每一位就是一个维度。我们不需要一次性处理所有维度的子集，而是像折纸一样，先处理第一维的累加，再处理第二维。
        
- **具体原理**:
    
    - **维度分解**：任何一个子集一定是通过将父集的某些“1”变成“0”得到的。
        
    - **状态转移**：在处理第 $i$ 位时，如果当前位置该位是 1，它就应该累加“该位是 0”时的对应状态。由于前面的维度已经处理完毕，这种累加是具有传递性的。

## 3. 实战部署

{% fold info @代码实现: 标准 SOS DP 算子 %}

```cpp
// dp[mask] 初始存储 A[mask]
void sos_dp( )
{
    // 依次处理第 i 个维度（二进制位）
    for( int i = 0; i < n; ++ i )
    {
        for( int mask = 0; mask < ( 1 << n ); ++ mask )
        {
            // 如果 mask 在该维度上是 1，则累加该维度上为 0 的对应子集状态
            if( ( mask >> i ) & 1 )
            {
                dp[mask] += dp[mask ^ ( 1 << i )];
            }
        }
    }
}
```

{% endfold %}

## 4. 知识关联

- **母题**: [[ARC100C Or Plus Max]] —— 补集思想与子集检索的本原体现。
    
- **关联笔记**: [[前缀和与差分]] —— SOS DP 的低维逻辑原型。