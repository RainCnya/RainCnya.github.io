---
title: '[Note] 最短路体系'
tags:
  - 图论/最短路
  - 难度/P3
categories:
  - 210_Atlas
  - 20_图论
  - 21_图论基础
abbrlink: a535be86
updated: '2025-12-24 19:05'
date: 2025-12-12 01:33:58
updated2: 2026-02-04 15:18:28
---
# 最短路体系

## 1. 生态位

- **识别**:
    
    1. 寻找从起点到终点的最小代价（权值非负用 Dijkstra，含负权用 SPFA）。
        
	2. **状态分层**: 有 $k$ 次免费/打折机会 $\to$ 分层图最短路。
            
	3. **逻辑判定**: 寻找负环（SPFA）或 最小环（Floyd）。
            
	4. **计数与推导**: 统计最短路方案数 $\to$ 最短路 DAG。
            
- **地位**: 图论的核心求路径工具。
    
- **用途**: 解决决策空间中的最优转换问题。将代数约束（如 $x_v - x_u \le w$）或组合状态（如余数分类）转化为图上的拓扑搜索。

## 2. 逻辑支点

### 2.1 核心原理：松弛

- **三角不等式**: 最短路的物理本质是“拉直”。对于任意边 $(u, v)$，若 $dist[v] > dist[u] + w$，说明我们找到了一条捷径，必须更新（松弛）。
    
- **算法对比**:
    
    - **Dijkstra**: **贪心**。每次锁定当前代价最小的点，它一定是最优的（无负权前提）。
        
    - **SPFA**: **纠错**。只要一个点的代价变小了，它的邻居就有可能变小，入队等待检查。
        
    - **Floyd**: **动态规划**。$dp[k][i][j]$ 表示允许经过前 $k$ 个点中转的最短路径。

### 2.2 进阶模型

- **分层图**: 当决策包含“特殊能力”（如 $K$ 次免费）时，我们将状态从一维的点 $u$ 升维到二维 $(u, k)$。
    
    $$dist[v][k] = \min(dist[v][k], dist[u][k] + w)$$$$dist[v][k+1] = \min(dist[v][k+1], dist[u][k] + 0)$$
- **最短路图**: 剥离原图中所有非最优的边，剩下的边构成一个 **DAG**。它是处理“最短路方案数”或“最长公共路径”的骨架子图。

$$
dist_{start}[u] + w(u, v) + dist_{end}[v] = dist_{start}[end]
$$


## 3. 实战部署

### 3.1 Dijkstra

1. 堆优化版 Dijkstra (适用于稀疏图) - $O(E \log V)$

{% fold info @Dijkstra 堆优化 %}
```cpp
// 堆优化版 Dijkstra (适用于稀疏图) - O(E log V)

struct State {
    ll d; int u;
    bool operator < ( const State& rhs ) const {
        return d > rhs.d;
    }
};

void dijkstra( int s ) 
{
    for( int i = 1; i <= n; ++ i ) dist[i] = inf;
    dist[s] = 0;
    
    priority_queue<State> pq;
    pq.push({ 0, s });

    while( !pq.empty( ) ) 
    {
        auto [d, u] = pq.top( );
        pq.pop( );
        
        if( d > dist[u] ) continue;

        for( auto& [v, w] : adj[u] ) 
        {
            if( dist[u] + w < dist[v] ) 
            {
                dist[v] = dist[u] + w;
                pq.push({ dist[v], v });
            }
        }
    }
}
```

{% endfold %}

2. 朴素版 Dijkstra (适用于稠密图) - $O(V^2)$

{% fold info @AcCode %}
```cpp
ll g[5005][5005]; // 朴素版通常用邻接矩阵
void dijkstra_naive( int s ) 
{
    for( int i = 1; i <= n; ++ i ) 
    {
        dist[i] = inf;
        vis[i] = false;
    }
    dist[s] = 0;

    for( int i = 1; i <= n; ++ i ) 
    {
        int t = -1;
        for( int j = 1; j <= n; ++ j ) 
        {
            if( !vis[j] && ( t == -1 || dist[j] < dist[t] ) ) t = j;
        }
        vis[t] = true;
        for( int j = 1; j <= n; ++ j ) 
        {
            dist[j] = min( dist[j], dist[t] + g[t][j] );
        }
    }
}
```
{% endfold %}

### 3.2 SPFA

适用于**含负权边**或需要判定**负环**（差分约束核心）的场景。

1. 基础 SPFA 判断负环 - $O(kE)$ ~ $O(VE)$

{% fold info @SPFA 负环判定 %}

```cpp
bool spfa_negative_cycle( int s ) 
{
    for( int i = 1; i <= n; ++ i ) 
    {
        dist[i] = inf;
        vis[i] = false;
        cnt[i] = 0;
    }
    dist[s] = 0;
    queue<int> q;
    q.push( s );
    vis[s] = true;

    while( !q.empty( ) ) 
    {
        int u = q.front( );
        q.pop( );
        vis[u] = false;

        for( auto& [v, w] : adj[u] ) 
        {
            if( dist[u] + w < dist[v] ) 
            {
                dist[v] = dist[u] + w;
                cnt[v] = cnt[u] + 1;
                if( cnt[v] >= n ) return true; // 存在负环
                
                if( !vis[v] ) 
                {
                    q.push( v );
                    vis[v] = true;
                }
            }
        }
    }
    return false;
}
```
{% endfold %}

2. SPFA + SLF 优化，在随机图上表现更优，但最坏复杂度不变

{% fold info @AcCode %}
```cpp
void spfa_slf( int s ) 
{
    for( int i = 1; i <= n; ++ i ) 
    {
        dist[i] = inf;
        vis[i] = false;
    }
    dist[s] = 0;
    deque<int> dq;
    dq.push_back( s );
    vis[s] = true;

    while( !dq.empty( ) ) 
    {
        int u = dq.front( );
        dq.pop_front( );
        vis[u] = false;

        for( auto& [v, w] : adj[u] ) 
        {
            if( dist[u] + w < dist[v] ) 
            {
                dist[v] = dist[u] + w;
                if( !vis[v] ) 
                {
                    // SLF 优化：如果当前点距离小于队头，插入队头
                    if( !dq.empty( ) && dist[v] < dist[dq.front( )] )   
                        dq.push_front( v );
                    else 
                        dq.push_back( v );
                    vis[v] = true;
                }
            }
        }
    }
}

```
{% endfold %}

### 3.3 Floyd

适用于**多源最短路**、**传递闭包**或**最小环**判定。

{% fold info @Floyd %}

```cpp
ll d[505][505];
void floyd( int n ) 
{
    for( int k = 1; k <= n; ++ k ) 
    {
        for( int i = 1; i <= n; ++ i ) 
        {
            for( int j = 1; j <= n; ++ j ) 
            {
                if( d[i][k] != inf && d[k][j] != inf ) 
                {
                    d[i][j] = min( d[i][j], d[i][k] + d[k][j] );
                }
            }
        }
    }
}
```
{% endfold %}

### 3.4 最短路图

{% fold info @最短路图构建 %}
```cpp
// 需先跑两遍 Dijkstra: S出发得 d1[], T出发(反图)得 d2[]
vector< int > dag_adj[maxn];
int indeg[maxn];

void build_dag( )
{
    for( int u = 1; u <= n; ++ u )
    {
        for( auto& [v, w] : adj[ u ] )
        {
            // 判定边 (u, v) 是否在最短路径上
            if( d1[u]  + w + d2[v] == d1[t] )
            {
                dag_adj[u].push_back(v);
                indeg[v] ++;
            }
        }
    }
}
// 之后可在 DAG 上进行拓扑排序 DP
```
{% endfold %}

## 4. 知识关联

- **关联笔记**:
    
    - [[差分约束]] —— 最短路作为逻辑求解器的应用（不等式组判定）。
        
    - [[同余最短路]] —— 将数值空间折叠为同余环，利用 Dijkstra 解决大范围背包问题。
        
- **实战案例 (Floyd 体系)**:
    
    - **最小环**: [[P6175 无向图的最小环]] (利用 Floyd 阶段 $k$ 寻找环路)
        
    - **时间限制**: [[P1119 灾后重建]] (利用 Floyd 阶段 $k$ 代表时间轴)
        
- **实战案例 (状态与建模)**:
    
    - **分层图**: [[P4568 飞行路线]] ($K$ 次免费机会的状态分层)
        
    - **状压扩展**: [[P3489 WIE-Hexer]] (武器库状态 $mask$ 压入距离维度)
        
    - **隐式图搜索**: [[CF2193E Product Queries]] (将乘法关系建模为图上的边)
        
    - **建模技巧**: [[P6833 雷雨]] (三点斯坦纳树，枚举汇合点)
        
- **实战案例 (结构分析)**:
    
    - **最短路树**: [[CF1076D Edge Deletion]] (保留最短路骨架)
        
    - **计数 DP**: [[P1144 最短路计数]] (最短路 DAG 上的拓扑递推)
        
    - **公共路径**: [[P2149 Elaxia 的路线]] (两条最短路图的交集)
        
- **实战案例 (判定与多源)**:
    
    - **分数规划**: [[P3199 最小圈]] (二分答案 + SPFA 判负环)
        
    - **多源染色**: [[P5304 旅行者]] (多源 Dijkstra + 染色法求最近点对)