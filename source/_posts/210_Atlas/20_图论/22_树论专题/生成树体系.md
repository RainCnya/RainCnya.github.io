---
title: '[Note] 生成树体系'
tags:
  - 图论/生成树
  - 树论/LCA
  - 难度/P3
categories:
  - 210_Atlas
  - 20_图论
  - 22_树论专题
abbrlink: cd7fb2f0
date: 2025-12-16 17:30:17
updated: 2025-12-24 19:07:57
updated2: 2026-02-05 23:01:51
---
# [L4] 生成树体系

## 1. 生态位

- **识别**:
    
    1. **显性连通**: "以最小代价连通所有点" ($N$ 个点选 $N-1$ 条边)。
        
    2. **瓶颈路**: 询问两点间路径上 "最大边权的最小值" 或 "最小边权的最大值"。
        
    3. **逆向删除**: "删除一些边使得图不连通" $\iff$ "保留最大生成森林"。
        
    4. **虚拟源点**: 只有点权没有边权，或者点权转化为边权。
        
- **地位**: 树论的构建工具。它是图论中将图降维为树的最主要手段，也是处理连通性与权值博弈的模型。
    
- **用途**: 解决网络设计成本问题、瓶颈路径查询（结合 LCA），以及作为复杂约束（如度数限制）下的基础模型。

## 2. 逻辑支点

### 2.1 核心原理：贪心

MST 的本质是 **“在不形成环的前提下，永远优先选择最有价值的边”**。

- **Kruskal (边贪心)**:
    
    - **逻辑**: 将所有边按权值排序。利用 **并查集** 维护连通性，若当前边连接的两个点未连通，则合并。
        
    - **适用**: 稀疏图，以及绝大多数 CP 竞赛题目（因为题目通常围绕“边”的性质做文章）。
        
- **Prim (点贪心)**:
    
    - **逻辑**: 从一个点出发，每次寻找离当前连通块最近的点。
        
    - **适用**: 稠密图（$M \approx N^2$）。在竞赛中不如 Kruskal 通用。
        

### 2.2 结构性质：环路与切分

- **环路**: 在一个环中，**权值最大**的那条边**一定不在**最小生成树中（除非有多条最大边）。 
		
	- _推论_: 向 MST 中加入一条非树边 $(u, v)$ 会形成一个环。删掉环上最大的树边，即可得到一棵新的生成树。这是求解 **次小生成树** 的核心。
    
- **瓶颈**: MST 上 $u$ 到 $v$ 的路径，是所有 $u$ 到 $v$ 的路径中，**最大边权最小**的路径。
    

## 3. 实战部署

### 3.1 Kruskal 基础模版

适用于 90% 的生成树问题，结合并查集。

{% fold info @Kruskal Template %}

```cpp
const int maxn = 200010;
const int maxm = 500010;

struct Edge {
    int u, v; ll w;
    // 权值升序 (最小生成树)
    bool operator < ( const Edge &oth ) const { return w < oth.w; }
} edges[maxm];

int fa[maxn];
int n, m;

int find( int x ) 
{ 
    if( fa[x] == x ) return x;
    return fa[x] = find( fa[x] ); 
}

ll kruskal( )
{
    sort( edges + 1, edges + m + 1 );
    for( int i = 1; i <= n; ++ i ) fa[i] = i;
    
    ll ans = 0;
    int cnt = 0;
    
    for( int i = 1; i <= m; ++ i )
    {
        int u = edges[i].u;
        int v = edges[i].v;
        ll w = edges[i].w;
        
        int fu = find( u ), fv = find( v );
        
        if( fu != fv )
        {
            fa[fu] = fv;
            ans += w;
            cnt ++;
            // 在此可构建 MST 图: adj[u].pb({v, w});
            if( cnt == n - 1 ) break;
        }
    }
    
    if( cnt < n - 1 ) return -1; // 不连通
    return ans;
}
```

{% endfold %}

### 3.2 瓶颈路模型 (Kruskal + LCA)

解决“两点间路径最大边权的最小值”问题。

{% fold info @Bottleneck Path Logic %}

```cpp
// 1. 跑最大/最小生成树，构建树形结构 adj
// 2. 树上倍增预处理：up[u][i] 祖先, min_w[u][i] 路径最值

void dfs( int u, int p, int w )
{
    dep[u] = dep[p] + 1;
    up[u][0] = p;
    min_w[u][0] = w; // u 到父节点的边权
    
    for( int i = 1; i < maxlg; ++ i )
    {
        up[u][i] = up[ up[u][i - 1] ][i - 1];
        // 维护路径上的最值 (min 或 max)
        min_w[u][i] = min( min_w[u][i - 1], min_w[ up[u][i - 1] ][i - 1] );
    }
    
    for( auto [v, w] : adj[u] )
    {
        if( v != p ) dfs( v, u, weight );
    }
}

// 3. LCA 查询时同步合并 min_w
// 参考 P1967 货车运输
```

{% endfold %}

## 4. 知识关联

- **关联笔记**:
    
    - [[并查集]] —— Kruskal 的依赖工具。
        
    - [[LCA 体系]] —— 处理生成树上的路径查询（瓶颈路、次小生成树）。
        
    - [[WQS 二分]] —— 处理带有限制的生成树问题。
        
- **实战案例 (基础建模)**:
    
    - **虚拟源点**: [[P1550 Watering Hole G]] (将点权转化为从超级源点出发的边权)
        
    - **逆向思维**: [[P2700 逐个击破]] (正向删边困难 $\to$ 逆向加边跑最大生成森林)
        
- **实战案例 (结构变体)**:
    
    - **瓶颈路**: [[P1967 货车运输]] (最大生成树 + LCA 维护路径最小值)
        
    - **次小生成树**: [[P4180 严格最小生成树]] (MST + 环路最大/次大边替换)
        
- **实战案例 (复杂约束)**:
    
    - **度数限制**: [[P5633 最小度限制生成树]] (WQS 二分：给 $s$ 的边增加附加费 $\Delta$ 来控制度数)
        
    - **双重代价**: [[CF76A Gift]] (枚举 $G$ 限制，动态维护 $S$ 的最小生成树)