---
title: '[L2] 60_字符串'
tags:
  - Meta/Guide
  - 难度/P4
categories:
  - 210_Atlas
  - 60_字符串
abbrlink: 6fb16570
date: 2026-01-04 00:00:00
---
# [L2] 60_字符串

> **核心哲学**：字符串算法不是在玩文字游戏，而是在海量字符中寻找特定的“印记”。
> 
> 本质：利用已经看过的部分，跳过不可能匹配的部分；
> 或者干脆给整段文字建一个像字典一样的“结构化索引”，实现瞬间定位。

## 1. 知识图谱与演化

- **核心工具**: 前缀复用、状态转移、后缀索引、对称中心。
    
- **演化路径**:
    
	1. **单模匹配**：学会利用匹配失败处的前缀信息，通过预处理跳转位置，避免从头开始的暴力回溯。
	    
	2. **多模并发**：当目标串变多时，将它们聚合成树形结构，让文本只扫一遍就能同时撞击所有目标。
	    
	3. **后缀全量化**：字符串算法的顶峰。通过对所有后缀进行排序或构建自动机，将子串查询、计数等问题转化为图上的路径或区间问题。
	    
	4. **对称逻辑**：利用回文串的中心对称特性，减少对重复区域的半径探测，或构建专门的回文索引结构。

## 2. 决策矩阵

- **长文本中寻找一个固定目标串**: 优先选 [[Note] KMP 算法]。
    
- **在一堆目标串中统计出现次数**: 采用 [[Note] AC 自动机]。
    
- **涉及“子串出现次数”、“不同子串个数”或“最长公共子串”**:
    
    - 若追求逻辑简洁且内存充裕，首选 [[Note] 后缀自动机]。
        
    - 若涉及字典序大规模排序或内存极度受限，采用 [[Note] 后缀数组]。
        
- **寻找最长回文子串**:
    
    - 线性时间内极速解决，用 [[Note] 曼纳海尔算法]。
        
    - 若涉及回文串的复杂嵌套关系或统计不同回文串个数，用 [[Note] 回文自动机]。
        
- **正统算法难以实现或需要模糊匹配**: 采用进制 [[Note] 哈希]。

## 3. 核心板块索引

### 3.1 匹配与自动机

- **[L3] 61 匹配与自动机**: 解决“在哪里出现了什么”的问题。
    
	- [[Note] KMP 算法]: 前缀复用的跳跃逻辑。
	    
	- [[Note] AC 自动机]: 多模式串并发跳转的失败指针。
	    
	- [[Note] 后缀自动机]: 压缩子串状态的终极结构。

### 3.2 结构化索引

- **[L3] 62 结构化索引**: 字符串的全局统计与排序工具。
    
	- [[Note] 后缀数组]: 后缀集合的倍增排序。
	    
	- [[Note] 哈希]: 字符串的数值化映射与模糊匹配。
		
	- [[Note] 后缀平衡树]: 动态维护后缀顺序的进阶结构。

### 3.3 回文处理

- **[L3]63 回文处理**: 利用对称性解决计数与长度问题。
    
	- [[Note] 曼纳海尔算法]: 线性回文半径探测。
	    
	- [[Note] 回文自动机]: 为回文串量身定制的字典树。

## 4. 依赖与规划

- **前置依赖**: 掌握字典树 (Trie)、基本递归逻辑、以及字符串进制 Hash 思想。
    
- **学习路径**:
    
    1. **P1 (基础)**：熟练写出 KMP、曼纳海尔算法以及字符串哈希，理解“利用已知信息减少重复探测”及“特征值压缩”的精髓。
        
    2. **P2 (中坚)**：攻克 AC 自动机。掌握在 Trie 树上通过 Fail 指针进行多模式串并行处理的逻辑。
        
    3. **P3 (顶尖)**：掌握后缀自动机 (SAM)、后缀数组 (SA) 与回文自动机 (PAM)。这是解决复杂子串逻辑、字典序统计及回文博弈问题的终极武器。

## 5. 题目归档

所有题目复盘请参考：[[06 字符串算法 归档数据库]]