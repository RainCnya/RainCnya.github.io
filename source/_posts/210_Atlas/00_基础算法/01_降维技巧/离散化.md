---
title: '[Note] 离散化'
tags:
  - 算法/离散化
  - 难度/P1
categories:
  - 210_Atlas
  - 00_基础算法
  - 01_降维技巧
abbrlink: 26262b8
date: 2026-01-04 00:00:00
---
# [L4] 离散化

## 1. 生态位

- **识别**:
    
    1. 数字的绝对值极大（如 $10^9$），导致数组开不下或值域相关算法失效。
        
    2. 题目逻辑只关心数字的大小关系（谁比谁大），而不关心数字之间具体的差值。
        
- **地位**: 权值类数据结构（如树状数组、线段树）的必备预处理。
    
- **用途**: 挤掉值域中的**空隙**，将大值域映射到紧凑的连续下标空间。

## 2. 逻辑支点

- **核心原理：映射**:
    
    - **物理直觉**：不管你原来的身份证号是多少，我们只看你在所有出现过的数字里排第几。只要相对顺序不变，逻辑就不变。
        
- **具体原理**:
    
    - **字典构建**：收集所有可能影响答案的数字（包括区间端点、询问点），进行排序并去重。
        
    - **全序保持**：映射函数 $f$ 必须是单调递增的，即 $A < B \iff f(A) < f(B)$。
        
    - **相邻性处理**：在涉及区间覆盖的逻辑中，如果需要区分 $x$ 和 $x+1$ 的空隙，离散化时需额外采样 $x+1$ 点，防止空隙被强制“挤没”。

	- **映射**：利用 `lower_bound` 检索原值在字典中的 `Rank`。

## 3. 实战部署

{% fold info @标准离散化模板 %}

```cpp
int a[maxn], b[maxn];
int n;

void discretize( )
{
    // 构建字典 b 数组
    for( int i = 1; i <= n; ++ i )
    {
        b[i] = a[i];
    }
    
    // 确立有序值域：排序 + 去重
    sort( b + 1, b + n + 1 );
    int m = unique( b + 1, b + n + 1 ) - ( b + 1 );
    
    // 映射：将原始值替换为在字典中的排名
    for( int i = 1; i <= n; ++ i )
    {
        a[i] = lower_bound( b + 1, b + m + 1, a[i] ) - b;
    }
}

// 还原逻辑：原值 = b[ a[i] ]
```

{% endfold %}

## 4. 知识关联

- **母题**: [[P1908 逆序对 BIT]] —— 离散化作为树状数组索引的母题。
    
- **关联笔记**: [[扫描线算法]] —— 离散化在几何面积并中的核心应用。