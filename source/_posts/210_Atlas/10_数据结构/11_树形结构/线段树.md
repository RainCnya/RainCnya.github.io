---
title: '[Note] 线段树'
tags:
  - 数据结构/线段树
  - 难度/P3
categories:
  - 210_Atlas
  - 10_数据结构
  - 11_树形结构
abbrlink: dba9a34f
date: 2026-01-26 00:00:00
---

# [L4]  线段树

## 1. 生态位

- **识别**:
    
    1. 涉及区间修改（覆盖、乘加、开方）与区间查询。
        
    2. 维护信息满足**结合律**，但未必满足可差分性（如区间最值、最大子段和）。
        
    3. 存在多种操作叠加，且操作间存在优先级（如先乘后加）。
        
- **地位**: 树形管理万能工具。它可以高效处理动态区间维护问题。
    
- **用途**: 通过分支解决了解决了动态区间信息维护复杂度， $O(N) \to O(\log N)$。

## 2. 逻辑支点

### 2.1 核心原理：分治

- **分治结构**： 将 $[1, N]$ 递归划分为 $O(N)$ 个平衡节点。
    
- **懒标记**：线段树的核心操作。它将更新操作暂存在区间节点上，只有在访问更深层的子节点时才进行下传，从而实现了“按需更新”，避免了 $O(N)$ 的暴力修改。

### 2.2 工程化：Info 与 Tag 

为了应对复杂的信息合并与标记叠加，我个人习惯采用抽象的结构体：

- **Info (信息体)**: 存储节点维护的值（如 `sum`, `mx`, `len`），并定义 `merge` 函数（即 `PushUp` 的核心）。
    
- **Tag (标记体)**: 存储待执行的修改操作（如 `add`, `mul`, `cover`），并定义 `apply` 函数（标记叠加协议）与 `update` 函数（信息更新协议）。

## 3. 实战部署

{% fold info @结构化线段树 (乘加混合协议) %}

```cpp
const int maxn = 2e5 + 5;
ll mod = 1e18;

struct Tag {
    ll mul = 1, add = 0;
    bool empty( ) { return mul == 1 && add == 0; }
    void clear( ) { mul = 1, add = 0; }
    void apply( const Tag& t ) {
        mul = ( mul * t.mul ) % mod;
        add = ( add * t.mul + t.add ) % mod;
    }
};

struct Info {
    ll sum = 0, len = 0;
    static Info merge( const Info& l, const Info& r ) {
        return { ( l.sum + r.sum ) % mod, l.len + r.len };
    }
    void update( const Tag& t ) {
        sum = ( sum * t.mul + t.add * len ) % mod;
    }
};

struct Node {
    int l, r;
    Info info;
    Tag tag;
} tr[ maxn << 2 ];
```

{% endfold %}

{% fold info @结构化线段树 (操作函数部分) %}
```cpp
void push_up( int u ) { 
    tr[u].info = Info::merge(tr[ls].info, tr[rs].info); 
}

void push_down( int u ) 
{
    if( tr[u].tag.empty( ) ) return;
    tr[ls].info.update( tr[u].tag );
    tr[rs].info.update( tr[u].tag );
    tr[ls].tag.apply( tr[u].tag );
    tr[rs].tag.apply( tr[u].tag );
    tr[u].tag.clear( );
}

void build( int u, int l, int r ) 
{
    tr[u].l = l, tr[u].r = r;
    tr[u].tag.clear( );
    if( l == r ) 
    {
        tr[u].info = { a[l] };
        return;
    }
    int mid = (l + r) >> 1;
    build( ls, l, mid );
    build( rs, mid + 1, r );
    push_up( u );
}

void modify( int u, int l, int r, const Tag& t ) 
{
    if( l <= tr[u].l && tr[u].r <= r )
    {
        tr[u].info.update( t );
        tr[u].tag.apply( t );
        return;
    }
    push_down( u );
    int mid = (tr[u].l + tr[u].r) >> 1;
    if( l <= mid ) modify( ls, l, r, t );
    if( mid < r ) modify( rs, l, r, t );
    push_up( u );
}

Info query( int u, int l, int r )
{
    if( l <= tr[u].l && tr[u].r <= r ) return tr[u].info;
    push_down( u );
    int mid = (tr[u].l + tr[u].r) >> 1;
    if( r <= mid ) return query( ls, l, r );
    if( mid < l ) return query( rs, l, r );
    return Info::merge( query( ls, l, r), query( rs, l, r ) );
}
```
{% endfold %}

{% fold info @权值线段树 (离散化平衡树替代) %}

```cpp
struct Info {
    ll cnt = 0, sum = 0;// 出现次数 // 权值总和
    static Info merge( const tInfo& l, const Info& r ) {
        return { l.cnt + r.cnt, l.sum + r.sum };
    }
};

// 线段树上二分：查找第 k 小的排名索引
int find_kth( int u, ll k ) {
    if( tr[ u ].l == tr[ u ].r ) return tr[ u ].l;
    if( tr[ ls ].info.cnt >= k ) return find_kth( ls, k );
    else return find_kth( rs, k - tr[ ls ].info.cnt );
}
```

{% endfold %}

{% fold info @扫描线 (无 PushDown 维护) %}
```cpp
void push_up( int u )
{
    if( tr[u].info.cnt > 0 )
    {
        tr[u].info.len = ys[ tr[u].r + 1 ] - ys[ tr[u].l ];
    }
    else
    {
        if ( tr[u].l == tr[u].r ) tr[u].info.len = 0;
        else tr[u].info.len = tr[ls].info.len + tr[rs].info.len;
    }
}
```

{% endfold %}

## 4. 知识关联

- **关联笔记**:
    
    - [[树状数组]] —— 处理**可差分/前缀**信息的轻量级替代方案。
        
    - [[线段树_信息合并]] —— 深入探讨 GSS 模型（最大子段和）等非线性合并逻辑。
        
- **实战案例**:
	    
	- **复合算子**: [[P3373 模板 线段树2]] (处理乘加冲突)
	    
	- **时间轴映射**: [[P4588 数学计算]] (处理 M 不一定为质数的逆元运算)
	    
	- **分布决策**: [[P3369 模板 普通平衡树 (权值线段树)]] (实现排名与分位)
	    
	- **特征映射**: [[P6186 冒泡排序]] (分析逆序对演化特征)