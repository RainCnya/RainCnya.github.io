---
title: "[Note] 二分体系"
tags:
  - 单调性/二分
  - 难度/P1/提高-
categories:
  - 00_Atlas
  - 00_基础算法
  - 02_排序与二分
abbrlink: 9f633e52
date: 2026-01-18
---
# [L4] 二分体系

## 1. 生态位

- **识别**:
    
    1. 题面出现“最大值最小化”或“最小值最大化”的关键词。
        
    2. 判定函数 `check(x)` 具有单调性。如果 $x$ 满足条件，则所有比 $x$ 小（或大）的数一定也满足条件。
        
- **地位**: 核心基础算法。它可以将“求解问题”转化为“判定问题”。
    
- **用途**: 强制将 $O(n)$ 或 $O(Ans)$ 的搜索复杂度压缩至 $O(\log n)$，核心在于利用单调性剪去无效的分支。

## 2. 逻辑支点

#### 2.1 **核心原理**: 

- 把搜索空间看成一条分界线。左边全是“行”，右边全是“不行”。二分的过程就是不断把范围减半，直到找到那个“行与不行”的交界点上。

- **具体推导**：

	- **整数二分**：个人习惯 $Ans$ 记录法，只要当前 $mid$ 合法，就记录然后接着搜。
		
	- **实数二分**：个人习惯 $100$ 次循环，$2^{-100}$ 精度理论上是肯定满足的。
	    
#### 2.2 **判定函数构造**: 

- 二分的核心难点——`check(mid)`函数怎么构建？通常配合差分、前缀和或贪心。
	
1. **直观判定**: 直接遍历或简单贪心即可得出结论。
    
2. **前缀和/差分判定**: 涉及区间资源冲突（如 [[P1083 借教室]]），利用差分将修改降至 $O(1)$，线性扫描判定。
    
3. **分数规划**: 求解 $\frac{\sum a_i}{\sum b_i} \ge mid$。通过代数变形转化为 $\sum ( a_i - mid \cdot b_i ) \ge 0$，寻找是否存在一组解使差值和非负。
    
4. **降维处理**: 二维网格切分，通过固定一个维度的边界，在另一个维度进行“刚好够就切”的贪心尝试。
    
## 3. 实战部署

{% fold info @整数二分模板 %}

```cpp
int solve( int L, int R )
{
	int ans = -1;
	while( L <= R )
	{
		int mid = L + ( ( R - L ) >> 1 );
		if( check( mid ) ) ans = mid, L = mid + 1;
		else R = mid - 1;
	}
	return ans;
}
```

{% endfold %}

{% fold info @实数二分模板 %}

```cpp
double solve_real( double L, double R )
{
	// 100 次迭代足够覆盖所有精度要求
	for( int i = 1; i <= 100; ++ i )
	{
		double mid = ( L + R ) / 2.0;
		if( check( mid ) ) L = mid;
		else R = mid;
	}
	return L;
}
```

{% endfold %}

{% fold info @进阶二分案例（01 分数规划 + 单调队列） %}

```cpp
// 核心逻辑：判定是否存在长度在 [S, T] 的子段均值 >= mid
bool check( double mid ) {
    // 1. 维度转换：b[i] = a[i] - mid，求前缀和 pre_sum
    for ( int i = 1; i <= n; ++ i ) {
        pre_sum[ i ] = pre_sum[ i - 1 ] + ( a[ i ] - mid );
    }

    deque< int > q;
    for ( int i = s; i <= n; ++ i ) {
        // 2. 维护区间 [i-t, i-s] 内 pre_sum[j] 的最小值
        int cand = i - s;
        while ( ! q.empty() && pre_sum[ q.back() ] >= pre_sum[ cand ] ) q.pop_back();
        q.push_back( cand );

        if ( q.front() < i - t ) q.pop_front();

        // 3. 判定：S_i - S_j_min >= 0 说明均值达标
        if ( pre_sum[ i ] - pre_sum[ q.front() ] >= 0 ) return true;
    }
    return false;
}
```

{% endfold %}

## 4. 知识粘附

- **母题**:  

	- [[P1083 借教室]]: 典型的“二分答案 + 差分判定”模型。

- **实战案例**：
    
	- [[P1419 寻找段落]]: “二分答案 + 分数规划 + 单调队列”模型。
		
	- [[P3017 Brownie Slicing G]] “二分答案 + 2D前缀和 + 贪心”模型。
		
	- [[P1314 聪明的质监员]] “二分答案 + 前缀和”模型
		
	- [[ABC440D Forbidden List 2]]：典型的“二分查询”优化。

- **关联笔记**：[[前缀和与差分]] —— 很多二分的 `check` 函数都是靠前缀和或贪心跑出来的。