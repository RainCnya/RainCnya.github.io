---
title: '[Note] 单调栈与队列'
tags:
  - 单调性/单调栈
  - 单调性/单调队列
  - 难度/P1/基础
categories:
  - 00_Atlas
  - 00_基础算法
  - 01_降维技巧
abbrlink: 17898bcd
date: 2026-01-04
---

# [L4] 单调栈与队列

## 1. 生态位

- **识别**:
    
    1. 题目要求找窗口里的最大或最小值。
        
    2. 题目要求找每个数字左边或右边第一个比它大或比它小的数。
        
- **地位**: 降维技巧中的进阶工具，是处理“局部最值”问题的物理模型。
    
- **用途**: 将原本需要反复回溯搜索的 $O(NK)$ 或 $O(N^2)$ 复杂度，通过一次线性扫描降维到 $O(N)$。
    
## 2. 逻辑支点

- **核心原理**: **及时的优胜劣汰**。
    
    - **逻辑直觉**：如果一个人比你年轻（下标更靠右），还比你强（权值更优），那么你就被优化了(bushi。
        
    - **物理本质**：我们只保留那些在未来可能成为答案的“潜力苗子”。
        
- **具体原理**:
    
    - **存储不变量**：容器内部必须保持严格的单调性（递增或递减）。
        
    - **信息载体**：必须存储**下标**。因为下标不仅告诉我们数字的大小，还告诉我们它什么时候“过期”。
        
    - **淘汰逻辑**：新元素进场前，从尾部不断踢走那些没它强且没它年轻的“弱者”。如果是队列，还要从头部踢走那些已经“过期”的老兵。

## 3. 实战部署

### 3.1 单调栈模板

* **策略**: 找右边第一个比我大的 $\to$ 维护**单调递减**栈。

{% fold info @Code: Monotonic Stack %}

```cpp
// ans[i] 存储 i 右边第一个比 a[i] 大的元素下标
stack<int> stk; 

for( int i = 1; i <= n; ++ i ) 
{
    // 破坏单调性 -> 结算时刻
    while( !stk.empty( ) && a[i] > a[ stk.top( ) ] ) 
    {
        ans[ stk.top( ) ] = i; 
        stk.pop( ); 
    }
    stk.push( i ); 
}
```

{% endfold %}

### 3.2 单调队列模板

- **策略**: 求最大值 $\to$ 维护**单调递减**队列。

{% fold info @Code: Monotonic Queue %}

```cpp
deque<int> q; // 存下标

for( int i = 1; i <= n; ++ i ) 
{
    // 1. 检查队头过期
    if( !q.empty( ) && q.front( ) <= i - K ) 
        q.pop_front( );
        
    // 2. 淘汰弱者
    while( !q.empty( ) && a[i] >= a[ q.back( ) ] ) 
        q.pop_back( );
        
    // 3. 入队 & 取值
    q.push_back( i );
    if( i >= K ) printf("%d ", a[ q.front( ) ] );
}
```

{% endfold %}

## 4. 知识关联

- **母题**:
		
	- [[P1886 滑动窗口]] —— 最本原的单调队列模型，理解 $O(N)$ 维护 RMQ 的起点。

- **实战案例**: 
		
	- **视角转换**: [[P2866 Bad Hair Day S]] 贡献法。
        
	- **降维单调队列**: [[P2216 理想的正方形]] 二维最值问题。
	    
	- **单调栈+悬线法**: [[P1950 长方形]] 注意去重技巧。
	    
	- **隐含单调性发现**: [[P2827 蚯蚓]] 优先队列的二次优化。

- 关联笔记
		
	- [[双指针]] : 单调队列可视为一种特殊的双指针。
	    
	- [[单调队列优化DP]] : 单调队列在状态转移中的高阶应用。